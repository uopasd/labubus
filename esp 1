local esplib = getgenv().esplib
if not esplib then
    esplib = {
        team_check = falsa,
        visibility_check = true,

        box = {
            enabled = true,
            type = "corner", -- normal, corner
            padding = 1.15,
            visible_color = Color3.new(1, 1, 1),
            invisible_color = Color3.fromRGB(160, 160, 160),
            outline = Color3.new(0, 0, 0),
        },
        healthbar = {
            enabled = true,
            fill = Color3.new(0, 1, 0),
            outline = Color3.new(0, 0, 0),
        },
        name = {
            enabled = true,
            fill = Color3.new(1, 1, 1),
            size = 13,
        },
        distance = {
            enabled = true,
            fill = Color3.new(1, 1, 1),
            size = 13,
        },
        tracer = {
            enabled = true,
            visible_color = Color3.new(1, 1, 1),
            invisible_color = Color3.fromRGB(160, 160, 160),
            outline = Color3.new(0, 0, 0),
            from = "bottom", -- mouse, head, top, bottom, center
        },
        tool = {
            enabled = true,
            show_box = true,
            show_name = true,
            show_distance = true,
            box_color = Color3.fromRGB(255, 255, 0),
            outline = Color3.new(0,0,0),
        }
    }
    getgenv().esplib = esplib
end

local espinstances = {}
local espfunctions = {}

local run_service = game:GetService("RunService")
local players = game:GetService("Players")
local user_input_service = game:GetService("UserInputService")
local camera = workspace.CurrentCamera
local local_player = players.LocalPlayer

local raycast_params = RaycastParams.new()
raycast_params.FilterType = Enum.RaycastFilterType.Exclude

local function get_bounding_box(instance)
    local min, max = Vector2.new(math.huge, math.huge), Vector2.new(-math.huge, -math.huge)
    local onscreen = false

    local parts_to_check = {}

    if instance:IsA("Model") then
        for _, v in ipairs(instance:GetDescendants()) do
            if v:IsA("BasePart") then
                table.insert(parts_to_check, v)
            end
        end
    elseif instance:IsA("BasePart") then
        table.insert(parts_to_check, instance)
    elseif instance:IsA("Tool") and instance:FindFirstChild("Handle") then
        table.insert(parts_to_check, instance.Handle)
    end

    local padding = esplib.box.padding

    for _, part in ipairs(parts_to_check) do
        local size = (part.Size / 2) * (part:IsA("HumanoidRootPart") and 1 or padding)
        local cf = part.CFrame
        local corners = {
            Vector3.new( size.X,  size.Y,  size.Z), Vector3.new(-size.X,  size.Y,  size.Z),
            Vector3.new( size.X, -size.Y,  size.Z), Vector3.new(-size.X, -size.Y,  size.Z),
            Vector3.new( size.X,  size.Y, -size.Z), Vector3.new(-size.X,  size.Y, -size.Z),
            Vector3.new( size.X, -size.Y, -size.Z), Vector3.new(-size.X, -size.Y, -size.Z),
        }

        for _, offset in ipairs(corners) do
            local pos, visible = camera:WorldToViewportPoint(cf:PointToWorldSpace(offset))
            if visible then
                local v2 = Vector2.new(pos.X, pos.Y)
                min = min:Min(v2)
                max = max:Max(v2)
                onscreen = true
            end
        end
    end

    return min, max, onscreen
end


function espfunctions.add_box(instance)
    if not instance or (espinstances[instance] and espinstances[instance].box) then return end

    local box = {}

    local outline = Drawing.new("Square")
    outline.Thickness = 3
    outline.Filled = false
    outline.Transparency = 1
    outline.Visible = false

    local fill = Drawing.new("Square")
    fill.Thickness = 1
    fill.Filled = false
    fill.Transparency = 1
    fill.Visible = false

    box.outline = outline
    box.fill = fill

    box.corner_fill = {}
    box.corner_outline = {}
    for i = 1, 8 do
        local line_outline = Drawing.new("Line")
        line_outline.Thickness = 3
        line_outline.Transparency = 1
        line_outline.Visible = false
        table.insert(box.corner_outline, line_outline)
        
        local line_fill = Drawing.new("Line")
        line_fill.Thickness = 1
        line_fill.Transparency = 1
        line_fill.Visible = false
        table.insert(box.corner_fill, line_fill)
    end

    espinstances[instance] = espinstances[instance] or {}
    espinstances[instance].box = box
end

function espfunctions.add_healthbar(instance)
    if not instance or (espinstances[instance] and espinstances[instance].healthbar) then return end
    local outline = Drawing.new("Square")
    outline.Thickness = 1
    outline.Filled = true
    outline.Transparency = 1

    local fill = Drawing.new("Square")
    fill.Filled = true
    fill.Transparency = 1

    espinstances[instance] = espinstances[instance] or {}
    espinstances[instance].healthbar = {
        outline = outline,
        fill = fill,
    }
end

function espfunctions.add_name(instance)
    if not instance or (espinstances[instance] and espinstances[instance].name) then return end
    local text = Drawing.new("Text")
    text.Center = true
    text.Outline = true
    text.Font = 1
    text.Transparency = 1

    espinstances[instance] = espinstances[instance] or {}
    espinstances[instance].name = text
end

function espfunctions.add_distance(instance)
    if not instance or (espinstances[instance] and espinstances[instance].distance) then return end
    local text = Drawing.new("Text")
    text.Center = true
    text.Outline = true
    text.Font = 1
    text.Transparency = 1

    espinstances[instance] = espinstances[instance] or {}
    espinstances[instance].distance = text
end

function espfunctions.add_tracer(instance)
    if not instance or (espinstances[instance] and espinstances[instance].tracer) then return end
    local outline = Drawing.new("Line")
    outline.Thickness = 3
    outline.Transparency = 1

    local fill = Drawing.new("Line")
    fill.Thickness = 1
    fill.Transparency = 1

    espinstances[instance] = espinstances[instance] or {}
    espinstances[instance].tracer = {
        outline = outline,
        fill = fill,
    }
end

function espfunctions.add_character_esp(character)
    if not (character and character:IsA("Model")) then return end
    espfunctions.add_box(character)
    espfunctions.add_healthbar(character)
    espfunctions.add_name(character)
    espfunctions.add_distance(character)
    espfunctions.add_tracer(character)
end

function espfunctions.add_tool_esp(tool)
    if not (tool and tool:IsA("Tool")) then return end
    espinstances[tool] = espinstances[tool] or {}
    espinstances[tool].is_tool = true 
    
    if esplib.tool.show_box then
        espfunctions.add_box(tool)
    end
    if esplib.tool.show_name then
        espfunctions.add_name(tool)
    end
    if esplib.tool.show_distance then
        espfunctions.add_distance(tool)
    end
end


run_service.RenderStepped:Connect(function()
    if local_player and local_player.Character then
        raycast_params.FilterDescendantsInstances = {local_player.Character}
    end

    for instance, data in pairs(espinstances) do
        if not instance or not instance.Parent then
            if data.box then
                data.box.outline:Remove()
                data.box.fill:Remove()
                for _, line in ipairs(data.box.corner_fill) do line:Remove() end
                for _, line in ipairs(data.box.corner_outline) do line:Remove() end
            end
            if data.healthbar then
                data.healthbar.outline:Remove()
                data.healthbar.fill:Remove()
            end
            if data.name then data.name:Remove() end
            if data.distance then data.distance:Remove() end
            if data.tracer then
                data.tracer.outline:Remove()
                data.tracer.fill:Remove()
            end
            espinstances[instance] = nil
            continue
        end

        local player_from_char = players:GetPlayerFromCharacter(instance)
        if esplib.team_check and player_from_char and local_player then
            if player_from_char.Team and local_player.Team and player_from_char.Team == local_player.Team then
                continue
            end
        end

        local is_tool = data.is_tool or false
        local primary_part = instance:IsA("Model") and instance.PrimaryPart or (instance:IsA("BasePart") and instance) or (instance:IsA("Tool") and instance.Handle)
        if not primary_part then continue end

        local min, max, onscreen = get_bounding_box(instance)
        
        local is_visible = false
        if esplib.visibility_check and onscreen then
            local origin = camera.CFrame.Position
            local direction = (primary_part.Position - origin)
            local result = workspace:Raycast(origin, direction.Unit * direction.Magnitude, raycast_params)
            if not result or (result.Instance:IsDescendantOf(instance)) then
                is_visible = true
            end
        end

        local box_fill_color = is_tool and esplib.tool.box_color or (is_visible and esplib.box.visible_color or esplib.box.invisible_color)
        local tracer_fill_color = is_visible and esplib.tracer.visible_color or esplib.tracer.invisible_color


        if data.box and (not is_tool or esplib.tool.show_box) then
            local box = data.box

            if esplib.box.enabled and onscreen then
                local x, y = min.X, min.Y
                local w, h = (max - min).X, (max - min).Y
                local len = math.min(w, h) * 0.25

                if esplib.box.type == "normal" then
                    box.outline.Position = min
                    box.outline.Size = max - min
                    box.outline.Color = is_tool and esplib.tool.outline or esplib.box.outline
                    box.outline.Visible = true

                    box.fill.Position = min
                    box.fill.Size = max - min
                    box.fill.Color = box_fill_color
                    box.fill.Visible = true
                    
                    for _, line in ipairs(box.corner_fill) do line.Visible = false end
                    for _, line in ipairs(box.corner_outline) do line.Visible = false end

                elseif esplib.box.type == "corner" then
                    local fill_lines, outline_lines = box.corner_fill, box.corner_outline
                    local outline_color = is_tool and esplib.tool.outline or esplib.box.outline
                    
                    local corners = {
                        { Vector2.new(x, y), Vector2.new(x + len, y) }, { Vector2.new(x, y), Vector2.new(x, y + len) },
                        { Vector2.new(x + w - len, y), Vector2.new(x + w, y) }, { Vector2.new(x + w, y), Vector2.new(x + w, y + len) },
                        { Vector2.new(x, y + h), Vector2.new(x + len, y + h) }, { Vector2.new(x, y + h - len), Vector2.new(x, y + h) },
                        { Vector2.new(x + w - len, y + h), Vector2.new(x + w, y + h) }, { Vector2.new(x + w, y + h - len), Vector2.new(x + w, y + h) },
                    }

                    for i = 1, 8 do
                        local from, to = corners[i][1], corners[i][2]
                        local dir = (to - from).Unit
                        local oFrom, oTo = from - dir, to + dir

                        local o = outline_lines[i]; o.From = oFrom; o.To = oTo; o.Color = outline_color; o.Visible = true
                        local f = fill_lines[i]; f.From = from; f.To = to; f.Color = box_fill_color; f.Visible = true
                    end
                    box.outline.Visible, box.fill.Visible = false, false
                end
            else
                box.outline.Visible = false; box.fill.Visible = false
                for _, line in ipairs(box.corner_fill) do line.Visible = false end
                for _, line in ipairs(box.corner_outline) do line.Visible = false end
            end
        end

        if data.healthbar and not is_tool then
            local outline, fill = data.healthbar.outline, data.healthbar.fill
            if not esplib.healthbar.enabled or not onscreen then
                outline.Visible = false; fill.Visible = false
            else
                local humanoid = instance:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    local height = max.Y - min.Y; local padding = 1
                    local x = min.X - 3 - 1 - padding; local y = min.Y - padding
                    local health = math.clamp(humanoid.Health / humanoid.MaxHealth, 0, 1)
                    local fillheight = height * health
                    outline.Color = esplib.healthbar.outline
                    outline.Position = Vector2.new(x, y)
                    outline.Size = Vector2.new(1 + 2 * padding, height + 2 * padding)
                    outline.Visible = true
                    fill.Color = esplib.healthbar.fill
                    fill.Position = Vector2.new(x + padding, y + (height + padding) - fillheight)
                    fill.Size = Vector2.new(1, fillheight)
                    fill.Visible = true
                else
                    outline.Visible = false; fill.Visible = false
                end
            end
        end

        if data.name and (not is_tool or esplib.tool.show_name) then
            if esplib.name.enabled and onscreen then
                local text = data.name; local center_x = (min.X + max.X) / 2; local y = min.Y - 15
                local name_str = instance.Name
                if player_from_char then name_str = player_from_char.DisplayName end
                text.Text = name_str; text.Size = esplib.name.size
                text.Color = is_tool and esplib.tool.box_color or esplib.name.fill
                text.Position = Vector2.new(center_x, y); text.Visible = true
            else
                data.name.Visible = false
            end
        end

        if data.distance and (not is_tool or esplib.tool.show_distance) then
            if esplib.distance.enabled and onscreen then
                local text = data.distance; local center_x = (min.X + max.X) / 2; local y = max.Y + 5
                local dist = (camera.CFrame.Position - primary_part.Position).Magnitude
                text.Text = tostring(math.floor(dist)) .. "m"; text.Size = esplib.distance.size
                text.Color = is_tool and esplib.tool.box_color or esplib.distance.fill
                text.Position = Vector2.new(center_x, y); text.Visible = true
            else
                data.distance.Visible = false
            end
        end

        if data.tracer and not is_tool then
            if esplib.tracer.enabled and onscreen then
                local outline, fill = data.tracer.outline, data.tracer.fill; local from_pos, to_pos = Vector2.new(), Vector2.new()
                if esplib.tracer.from == "mouse" then
                    local mouse_location = user_input_service:GetMouseLocation()
                    from_pos = Vector2.new(mouse_location.X, mouse_location.Y)
                elseif esplib.tracer.from == "head" then
                    local head = instance:FindFirstChild("Head")
                    if head then
                        local pos, visible = camera:WorldToViewportPoint(head.Position)
                        from_pos = visible and Vector2.new(pos.X, pos.Y) or Vector2.new(camera.ViewportSize.X/2, 0)
                    else
                        from_pos = Vector2.new(camera.ViewportSize.X/2, 0)
                    end
                elseif esplib.tracer.from == "top" then
                    from_pos = Vector2.new(camera.ViewportSize.X/2, 0)
                elseif esplib.tracer.from == "bottom" then
                    from_pos = Vector2.new(camera.ViewportSize.X/2, camera.ViewportSize.Y)
                elseif esplib.tracer.from == "center" then
                    from_pos = Vector2.new(camera.ViewportSize.X/2, camera.ViewportSize.Y/2)
                end
                to_pos = (min + max) / 2
                outline.From = from_pos; outline.To = to_pos; outline.Color = esplib.tracer.outline; outline.Visible = true
                fill.From = from_pos; fill.To = to_pos; fill.Color = tracer_fill_color; fill.Visible = true
            else
                data.tracer.outline.Visible = false; data.tracer.fill.Visible = false
            end
        end
    end
end)

for k, v in pairs(espfunctions) do
    esplib[k] = v
end

return esplib
