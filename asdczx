local esp = loadstring(game:HttpGet(('https://raw.githubusercontent.com/inveris1337/storage/refs/heads/main/esp_rw'), true))();
loadstring(game:HttpGet("https://raw.githubusercontent.com/uopasd/labubus/refs/heads/main/Gui"))()

local MainWindow = Library:Navigation({Size = UDim2.fromOffset(125, 40)})

local MainNavigationTab = MainWindow:CreateTab({Icon = "rbxassetid://130387207582017", MainWindow = true})
local PlayerListNavigationTab = MainWindow:CreateTab({Icon = "rbxassetid://130785050448042", PlayerList = true})
local ConfigsNavigationTab = MainWindow:CreateTab({Icon = "rbxassetid://102836483092386", Configs = true})
local SettingsNavigationTab = MainWindow:CreateTab({Icon = "rbxassetid://85296088181915", Settings = true})

local Main = MainNavigationTab:Window({
	Name = "buckshot.solution",
	Size = UDim2.fromOffset(600, 743)
})


local AimbotTab = Main:CreateTab({Name = "Aimbot"})
local VisualTab = Main:CreateTab({Name = "Visual"})
local GunmodsTab = Main:CreateTab({Name = "Gun mods"})
local Misc = Main:CreateTab({Name = "miscellaneous"})


local AimbotSection = AimbotTab:Section({Name = "Aimbot Settings", Side = "Left"})
local SilentSettion = AimbotTab:Section({Name = "Silent Settings", Side = "Right"})
local MeleeAura = AimbotTab:Section({Name = "Melee aura", Side = "Left"})
local Hvkilaura = AimbotTab:Section({Name = "Hv kill aura", Side = "right"})
local rage = AimbotTab:Section({Name = "RageBot", Side = "right"})
local Control = AimbotTab:Section({Name = "Controls", Side = "Left"})

local ESPSection = VisualTab:Section({Name = "Visual", Side = "Left"})
local ESPDropdowns = VisualTab:Section({Name = "Visuals Settings", Side = "Right"})
local BulletTracer = VisualTab:Section({Name = "Bullet tracer", Side = "Left"})
local ESPHighlight = VisualTab:Section({Name = "some things", Side = "Right"})

local GunMds = GunmodsTab:Section({Name = "Gun Mods", Side = "Left"})

local misc = Misc:Section({Name = "miscellaneous", Side = "Left"})
local misc1 = Misc:Section({Name = "Auto break", Side = "Right"})
local misc2 = Misc:Section({Name = "Auto Pick & auto Claim/Respawn", Side = "Left"})
local misc3 = Misc:Section({Name = "Speed & Jump", Side = "Right"})
local misc4 = Misc:Section({Name = "Farm (i think)", Side = "Left"})

--locals

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local Mouse = LocalPlayer:GetMouse()
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local plrs = game:GetService("Players")
plrs = game:GetService("Players")
local run = game:GetService("RunService")
me = plrs.LocalPlayer
run = game:GetService("RunService")
input = game:GetService("UserInputService")
camera = workspace.CurrentCamera
tween = game:GetService("TweenService")
functions = {}
remotes = {}

--locals
--aimbot logic

SectionSettings = {
	SilentAim = {
		DrawSize = 50,
		TargetPart = "Head",
		CheckWall = false,
		UseHitChance = false,
		HitChance = 80,
		CheckTeam = false,
		DrawCircle = false,
		DrawColor = Color3.fromRGB(255, 255, 255)
	},
	MeleeAura = {
		ShowAnim = false,
		Distance = 20,
		TargetPart = "Head",
		CheckTeam = false
	},
	AimBot = {
		Draw = false,
		DrawSize = 50,
		DrawColor = Color3.fromRGB(255, 255, 255),
		TargetPart = "Head",
		CheckWall = false,
		CheckTeam = false,
		Velocity = false
	}
}

ValidAimbotTargetParts = {"Head", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg"}
ValidSilentTargetParts = {"Head", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg"}
ValidMeleeTargetParts = {"Head", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg"}
remote1 = game:GetService("ReplicatedStorage").Events["XMHH.2"]
remote2 = game:GetService("ReplicatedStorage").Events["XMHH2.2"]

AimbotEnabled = false
Pressed = false
AimTarget = nil
CanUsing = false
Predict = 15
AimbotCircle = nil
AimbotCircleOutline = nil
AimbotCirclePos = nil

function GetClosestTarget()
	local Closest, ClosestDist = nil, SectionSettings.AimBot.DrawSize
	for _, Player in pairs(Players:GetPlayers()) do
		if Player ~= LocalPlayer and Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") then
			local Pos, OnScreen = Camera:WorldToViewportPoint(Player.Character.HumanoidRootPart.Position)
			if OnScreen then
				if SectionSettings.AimBot.CheckTeam and Player.Team == LocalPlayer.Team then continue end
				if SectionSettings.AimBot.CheckWall then
					local Ignore = {Camera, LocalPlayer.Character, Player.Character}
					if Player.Parent ~= workspace then table.insert(Ignore, Player.Parent) end
					local CheckPart = Player.Character:FindFirstChild("HumanoidRootPart")
					if not CheckPart then continue end
					local Obstructed = #Camera:GetPartsObscuringTarget({CheckPart.Position}, Ignore) > 0
					if Obstructed then continue end
				end
				local Distance = (Vector2.new(Pos.X, Pos.Y) - UserInputService:GetMouseLocation()).Magnitude
				if Distance < ClosestDist then
					ClosestDist = Distance
					Closest = Player
				end
			end
		end
	end
	return Closest
end

function RunAimbot()
	UserInputService.InputBegan:Connect(function(Key)
		if not UserInputService:GetFocusedTextBox() and Key.UserInputType == Enum.UserInputType.MouseButton2 then
			Pressed = true
			AimTarget = GetClosestTarget()
		end
	end)

	UserInputService.InputEnded:Connect(function(Key)
		if not UserInputService:GetFocusedTextBox() and Key.UserInputType == Enum.UserInputType.MouseButton2 then
			Pressed = false
			AimTarget = nil
		end
	end)

	RunService.RenderStepped:Connect(function()
		if AimbotEnabled then
			local Magnitude = (Camera.Focus.Position - Camera.CFrame.Position).Magnitude
			CanUsing = Magnitude <= 1.5

			if Pressed and AimTarget and AimTarget.Character then
				local Humanoid = AimTarget.Character:FindFirstChild("Humanoid")
				local TargetPart = AimTarget.Character:FindFirstChild(SectionSettings.AimBot.TargetPart)

				if Humanoid and Humanoid.Health > 0 and CanUsing and TargetPart then
					local TargetPosition = TargetPart.Position
					if SectionSettings.AimBot.Velocity then
						TargetPosition += TargetPart.Velocity / Predict
					end
					if SectionSettings.AimBot.Smooth then
						Camera.CFrame = Camera.CFrame:Lerp(CFrame.new(Camera.CFrame.Position, TargetPosition), SectionSettings.AimBot.SmoothSize)
					else
						Camera.CFrame = CFrame.new(Camera.CFrame.Position, TargetPosition)
					end
				end
			end

			if SectionSettings.AimBot.Draw then
				if not AimbotCircle then
					AimbotCircleOutline = Drawing.new("Circle")
					AimbotCircleOutline.Color = Color3.new(0, 0, 0)
					AimbotCircleOutline.Thickness = 2
					AimbotCircleOutline.Radius = SectionSettings.AimBot.DrawSize
					AimbotCircleOutline.Filled = false
					AimbotCircleOutline.Visible = true

					AimbotCircle = Drawing.new("Circle")
					AimbotCircle.Color = SectionSettings.AimBot.DrawColor
					AimbotCircle.Thickness = 1
					AimbotCircle.Radius = SectionSettings.AimBot.DrawSize
					AimbotCircle.Filled = false
					AimbotCircle.Visible = true

					AimbotCirclePos = RunService.Heartbeat:Connect(function()
						local mousePos = UserInputService:GetMouseLocation()
						AimbotCircle.Position = mousePos
						AimbotCircleOutline.Position = mousePos
						AimbotCircle.Radius = SectionSettings.AimBot.DrawSize
						AimbotCircleOutline.Radius = SectionSettings.AimBot.DrawSize
						AimbotCircle.Color = SectionSettings.AimBot.DrawColor
					end)
				end
			else
				if AimbotCircle then AimbotCircle:Remove(); AimbotCircle = nil end
				if AimbotCircleOutline then AimbotCircleOutline:Remove(); AimbotCircleOutline = nil end
				if AimbotCirclePos then AimbotCirclePos:Disconnect(); AimbotCirclePos = nil end
			end
		end
	end)
end

AimbotSection:Toggle({
	Name = "Enable Aimbot",
	Default = false,
	Flag = "EnableAim",
	Callback = function(state)
		AimbotEnabled = state
	end
})

AimbotSection:Toggle({
	Name = "Enable FOV",
	Default = false,
	Flag = "EnableFov",
	Callback = function(state)
		SectionSettings.AimBot.Draw = state
	end
})

AimbotSection:Toggle({
	Name = "Check Team",
	Default = false,
	Flag = "CheckTeam",
	Callback = function(state)
		SectionSettings.AimBot.CheckTeam = state
	end
})

AimbotSection:Toggle({
	Name = "Check Wall",
	Default = false,
	Flag = "CheckWall",
	Callback = function(state)
		SectionSettings.AimBot.CheckWall = state
	end
})

AimbotSection:Toggle({
	Name = "Velocity Prediction",
	Default = false,
	Flag = "VelocityPrediction",
	Callback = function(state)
		SectionSettings.AimBot.Velocity = state
	end
})

AimbotSection:Toggle({
	Name = "Enable Smooth",
	Default = false,
	Flag = "EnableSmooth",
	Callback = function(state)
		SectionSettings.AimBot.Smooth = state
	end
})

AimbotSection:Slider({
	Name = "FOV Size",
	Flag = "FovSize",
	Min = 10,
	Max = 600,
	Default = 50,
	Decimal = 1,
	Callback = function(val)
		SectionSettings.AimBot.DrawSize = val
	end
})

AimbotSection:Slider({
	Name = "Smooth Value",
	Flag = "SmoothValue",
	Min = 0.001,
	Max = 1,
	Default = 0.001,
	Decimal = 0.001,
	Callback = function(val)
		SectionSettings.AimBot.SmoothSize = val
	end
})

AimbotSection:Dropdown({
	Name = "AimPart",
	Default = "Head",
	Content = ValidAimbotTargetParts,
	Flag = "AimPart",
	Callback = function(choice)
		SectionSettings.AimBot.TargetPart = choice
	end
})

RunAimbot()

local circle = Drawing.new("Circle")
circle.Visible = false
circle.Transparency = 1
circle.Thickness = 0.5
circle.Color = SectionSettings.SilentAim.DrawColor
circle.Filled = false
circle.Radius = SectionSettings.SilentAim.DrawSize

local circleOutline = Drawing.new("Circle")
circleOutline.Visible = false
circleOutline.Transparency = 1
circleOutline.Thickness = circle.Thickness + 1.5
circleOutline.Color = Color3.new(0, 0, 0)
circleOutline.Filled = false
circleOutline.Radius = circle.Radius

local renderConnection = nil
function UpdateCircle()
	if renderConnection then renderConnection:Disconnect() end
	if functions.silentaimF and SectionSettings.SilentAim.DrawCircle then
		renderConnection = game:GetService("RunService").RenderStepped:Connect(function()
			local mouseLocation = game:GetService("UserInputService"):GetMouseLocation()
			local mouseVec = Vector2.new(mouseLocation.X, mouseLocation.Y)

			circle.Position = mouseVec
			circle.Radius = SectionSettings.SilentAim.DrawSize
			circle.Color = SectionSettings.SilentAim.DrawColor
			circle.Visible = true

			circleOutline.Position = mouseVec
			circleOutline.Radius = circle.Radius
			circleOutline.Visible = true
		end)
	else
		circle.Visible = false
		circleOutline.Visible = false
	end
end

function UrTargetFunc()
	if not functions.silentaimF then return nil end

	local closestPlayer = nil
	local targetPart = nil
	local minDistance = SectionSettings.SilentAim.DrawSize
	local mousePos = game:GetService("UserInputService"):GetMouseLocation()

	for _, player in ipairs(game:GetService("Players"):GetPlayers()) do
		if player == game.Players.LocalPlayer or not player.Character or player.Character:FindFirstChildOfClass("ForceField") then continue end
		if SectionSettings.SilentAim.CheckTeam and player.Team == game.Players.LocalPlayer.Team then continue end

		local tempPart = nil
		local closestDist = math.huge

		if SectionSettings.SilentAim.TargetPart == "Closest" then
			for _, partName in ipairs(ValidSilentTargetParts) do
				local part = player.Character:FindFirstChild(partName)
				if part then
					local screenPos, onScreen = workspace.CurrentCamera:WorldToViewportPoint(part.Position)
					if onScreen then
						local dist = (Vector2.new(mousePos.X, mousePos.Y) - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
						if dist < closestDist then
							closestDist = dist
							tempPart = part
						end
					end
				end
			end
		else
			tempPart = SectionSettings.SilentAim.TargetPart == "Random"
				and player.Character:FindFirstChild(ValidSilentTargetParts[math.random(1, #ValidSilentTargetParts)])
				or player.Character:FindFirstChild(SectionSettings.SilentAim.TargetPart or "Head")
		end

		if tempPart then
			if SectionSettings.SilentAim.CheckWall then
				local ignoreList = {workspace.CurrentCamera, game.Players.LocalPlayer.Character, player.Character}
				local parts = workspace.CurrentCamera:GetPartsObscuringTarget({tempPart.Position}, ignoreList)
				if #parts > 0 then continue end
			end

			local screenPos, onScreen = workspace.CurrentCamera:WorldToViewportPoint(tempPart.Position)
			if onScreen then
				local dist = (Vector2.new(mousePos.X, mousePos.Y) - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
				if dist < minDistance then
					minDistance = dist
					closestPlayer = player
					targetPart = tempPart
				end
			end
		end
	end

	if closestPlayer and targetPart and SectionSettings.SilentAim.UseHitChance then
		if math.random(1, 100) > SectionSettings.SilentAim.HitChance then
			return nil
		end
	end

	return closestPlayer
end

SilentSettion:Toggle({
	Name = "Enable Silent",
	Default = false,
	Flag = "EnableSmooth",
	Callback = function(Value)
		functions.silentaimF = Value
		UpdateCircle()
		if not Value then
			currentTarget = nil
			if remotes.SilentAimTask then
				task.cancel(remotes.SilentAimTask)
				remotes.SilentAimTask = nil
			end
			if visualizeConnection then
				visualizeConnection:Disconnect()
				visualizeConnection = nil
			end
		else
			VisualizeEvent = game:GetService("ReplicatedStorage").Events2.Visualize
			DamageEvent = game:GetService("ReplicatedStorage").Events["ZFKLF__H"]
			remotes.SilentAimTask = task.spawn(function()
				while functions.silentaimF do
					currentTarget = UrTargetFunc()
					game:GetService("RunService").Heartbeat:Wait()
				end
			end)
			visualizeConnection = VisualizeEvent.Event:Connect(function(_, ShotCode, _, Gun, _, StartPos, BulletsPerShot)
				if not functions.silentaimF or not Gun or not currentTarget or not currentTarget.Character or currentTarget.Character:FindFirstChildOfClass("ForceField") then return end
				local playerTool = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChildOfClass("Tool")
				if not playerTool or Gun ~= playerTool then return end

				local HitPart
				if SectionSettings.SilentAim.TargetPart == "Closest" then
					local minPartDistance = math.huge
					for _, partName in ipairs(ValidSilentTargetParts) do
						local part = currentTarget.Character:FindFirstChild(partName)
						if part then
							local screenPos, onScreen = workspace.CurrentCamera:WorldToViewportPoint(part.Position)
							if onScreen then
								local distance = (Vector2.new(mousePos.X, mousePos.Y) - Vector2.new(screenPos.X, screenPos.Y)).Magnitude
								if distance < minPartDistance then
									minPartDistance = distance
									HitPart = part
								end
							end
						end
					end
				else
					HitPart = SectionSettings.SilentAim.TargetPart == "Random" and currentTarget.Character:FindFirstChild(ValidSilentTargetParts[math.random(1, #ValidSilentTargetParts)]) or currentTarget.Character:FindFirstChild(SectionSettings.SilentAim.TargetPart or "Head")
				end

				if not HitPart then return end
				local HitPos = HitPart.Position
				local Bullets = {}
				for i = 1, math.clamp(#BulletsPerShot, 1, 100) do
					table.insert(Bullets, CFrame.new(StartPos, HitPos).LookVector)
				end

				task.wait(0.005)
				for Index, LookVector in ipairs(Bullets) do
					DamageEvent:FireServer("üßà", Gun, ShotCode, Index, HitPart, HitPos, LookVector)
				end
			end)
		end
	end
})

SilentSettion:Toggle({
	Name = "Fov",
	Default = false,
	Flag = "",
	Callback = function(Value)
		SectionSettings.SilentAim.DrawCircle = Value
		UpdateCircle()
	end
})

SilentSettion:Toggle({
	Name = "Use Hit Chance",
	Default = false,
	Flag = "",
	Callback = function(Value)
		SectionSettings.SilentAim.UseHitChance = Value
	end
})

SilentSettion:Toggle({
	Name = "Check Wall",
	Default = false,
	Flag = "",
	Callback = function(Value)
		SectionSettings.SilentAim.CheckWall = Value
	end
})

SilentSettion:Toggle({
	Name = "Check Team",
	Default = false,
	Flag = "",
	Callback = function(Value)
		SectionSettings.SilentAim.CheckTeam = Value
	end
})

SilentSettion:Slider({
	Name = "Hit Chance",
	Flag = "",
	Min = 0,
	Max = 100,
	Default = 89,
	Decimal = 1,
	Callback = function(Value)
		SectionSettings.SilentAim.HitChance = Value
	end
})

SilentSettion:Slider({
	Name = "Fov",
	Flag = "",
	Min = 0,
	Max = 450,
	Default = 50,
	Decimal = 1,
	Callback = function(Value)
		SectionSettings.SilentAim.DrawSize = Value
		circle.Radius = Value
	end
})

SilentSettion:Dropdown({
	Name = "HitBox silent",
	Default = "Head",
	Content = {"Head", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg", "Random", "Closest"},
	Flag = "",
	Callback = function(choice)
		SectionSettings.SilentAim.TargetPart = choice
	end
})


MeleeAura:Toggle({
	Name = "Melee Aura",
	Default = false,
	Flag = "",
	Callback = function(value)
		_G.MeleeAuraEnabled = value

		if value then
			local AttachTick = tick()
			local AttachCD = {
				["Fists"] = 0.05,
				["BBaton"] = 0.5,
				["__ZombieFists1"] = 0.35,
				["__ZombieFists2"] = 0.37,
				["__ZombieFists3"] = 0.22,
				["__ZombieFists4"] = 0.4,
				["__XFists"] = 0.35,
				["Balisong"] = 0.3,
				["Bat"] = 1.2,
				["Bayonet"] = 0.6,
				["BlackBayonet"] = 0.5,
				["CandyCrowbar"] = 2.5,
				["Chainsaw"] = 3,
				["Crowbar"] = 1.2,
				["Clippers"] = 0.6,
				["CursedDagger"] = 0.8,
				["DELTA-X04"] = 0.6,
				["ERADICATOR"] = 2,
				["ERADICATOR-II"] = 2,
				["Fire-Axe"] = 1.6,
				["GoldenAxe"] = 0.75,
				["Golfclub"] = 1.2,
				["Hatchet"] = 0.7,
				["Katana"] = 0.6,
				["Knuckledusters"] = 0.5,
				["Machete"] = 0.3,
				["Metal-Bat"] = 1.3,
				["Nunchucks"] = 0.3,
				["PhotonBlades"] = 0.8,
				["Rambo"] = 0.8,
				["ReforgedKatana"] = 0.85,
				["Rendbreaker"] = 1.5,
				["RoyalBroadsword"] = 1,
				["Sabre"] = 0.7,
				["Scythe"] = 1.1,
				["Shiv"] = 0.5,
				["Shovel"] = 2.4,
				["SlayerSword"] = 1.5,
				["Sledgehammer"] = 2.2,
				["Taiga"] = 0.7,
				["Tomahawk"] = 0.85,
				["Wrench"] = 0.6,
				["_BFists"] = 0.35,
				["_FallenBlade"] = 1.1,
				["_Sledge"] = 2.2,
				["new_oldSlayerSword"] = 1.5
			}

			if not remotes.MeleeAuraTask then
				remotes.MeleeAuraTask = task.spawn(function()
					local function Attack(target)
						if not (target and target:FindFirstChild("Head")) then return end
						if not me.Character then return end
						local TOOL = me.Character:FindFirstChildOfClass("Tool")
						if not TOOL then return end

						local attachcd = AttachCD[TOOL.Name] or 0.5
						if tick() - AttachTick >= attachcd then
							local result = remote1:InvokeServer("üçû", tick(), TOOL, "43TRFWX", "Normal", tick(), true)

							if SectionSettings.MeleeAura.ShowAnim then
								local anim = TOOL:FindFirstChild("AnimsFolder") and TOOL.AnimsFolder:FindFirstChild("Slash1")
								if anim then
									local animator = me.Character:FindFirstChildOfClass("Humanoid"):FindFirstChild("Animator")
									if animator then
										animator:LoadAnimation(anim):Play(0.1, 1, 1.3)
									end
								end
							end

							task.wait(0.3 + math.random() * 0.2)

							local Handle = TOOL:FindFirstChild("WeaponHandle") or TOOL:FindFirstChild("Handle") or me.Character:FindFirstChild("Left Arm")
							local targetPart = SectionSettings.MeleeAura.TargetPart == "Random"
								and target:FindFirstChild(ValidMeleeTargetParts[math.random(1, #ValidMeleeTargetParts)])
								or target:FindFirstChild(SectionSettings.MeleeAura.TargetPart) or target:FindFirstChild("Right Arm")
							if not targetPart then return end

							local args = {
								"üçû", tick(), TOOL, "2389ZFX34", result, true, Handle,
								targetPart, target, me.Character.HumanoidRootPart.Position, targetPart.Position
							}

							if TOOL.Name == "Chainsaw" then
								for _ = 1, 15 do remote2:FireServer(unpack(args)) end
							else
								remote2:FireServer(unpack(args))
							end

							AttachTick = tick()
						end
					end

					while _G.MeleeAuraEnabled do
						local mychar = me.Character or me.CharacterAdded:Wait()
						if mychar and mychar:FindFirstChild("HumanoidRootPart") then
							for _, a in ipairs(plrs:GetPlayers()) do
								if a ~= me and a.Character and a.Character:FindFirstChild("HumanoidRootPart") then
									if SectionSettings.MeleeAura.CheckTeam and a.Team == me.Team then continue end
									local dist = (mychar.HumanoidRootPart.Position - a.Character.HumanoidRootPart.Position).Magnitude
									if dist < SectionSettings.MeleeAura.Distance
										and a.Character:FindFirstChildOfClass("Humanoid").Health > 15
										and not a.Character:FindFirstChildOfClass("ForceField") then
										Attack(a.Character)
									end
								end
							end
						end
						run.Heartbeat:Wait()
					end
				end)
			end
		else
			if remotes.MeleeAuraTask then
				task.cancel(remotes.MeleeAuraTask)
				remotes.MeleeAuraTask = nil
			end
		end
	end
})

MeleeAura:Toggle({
	Name = "Show Animation",
	Default = false,
	Flag = "",
	Callback = function(value)
		SectionSettings.MeleeAura.ShowAnim = value
	end
})

MeleeAura:Toggle({
	Name = "Check Team",
	Default = false,
	Flag = "",
	Callback = function(value)
		SectionSettings.MeleeAura.CheckTeam = value
	end
})

MeleeAura:Slider({
	Name = "Melee Aura Distance",
	Flag = "",
	Min = 0,
	Max = 20,
	Default = 15,
	Decimal = 1,
	Callback = function(Value)
		SectionSettings.MeleeAura.Distance = Value
	end
})

MeleeAura:Dropdown({
	Name = "HitBox melee aura",
	Default = "Head",
	Content = ValidMeleeTargetParts,
	Flag = "",
	Callback = function(value)
		SectionSettings.MeleeAura.TargetPart = value
	end
})

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer

_G.HvKillaura = true
local remote4 = nil
local isPlayerAlive = false
local HeatAuraRadius = 25
local HeatAuraMode = "Single"

local function disableHvKillaura()
	if not remote4 then return end
	pcall(function()
		remote4:InvokeServer("ToggleEyes", false)
	end)
	pcall(function()
		remote4:InvokeServer("ToggleLaser", false, false)
	end)
end

local function hasCompoundXVision()
	local character = LocalPlayer.Character
	local success, result = pcall(function()
		return character and character:FindFirstChild("_CompoundXVision") and character._CompoundXVision:FindFirstChild("RemoteFunction")
	end)
	return success and result or nil
end

local function checkPlayerAlive()
	local character = LocalPlayer.Character
	local humanoid = character and character:FindFirstChild("Humanoid")
	isPlayerAlive = character and humanoid and humanoid.Health > 0
	return isPlayerAlive
end

local function getAllTargets()
	local localCharacter = LocalPlayer.Character
	local localCharacterName = localCharacter and localCharacter.Name or ""
	local targets = {}

	for _, character in ipairs(Workspace.Characters:GetChildren()) do
		if character.Name ~= localCharacterName and character:FindFirstChild("Head") and character:FindFirstChild("Humanoid") and character.Humanoid.Health > 0 then
			local rootPos = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and LocalPlayer.Character.HumanoidRootPart.Position or Vector3.new(0,0,0)
			if (character.Head.Position - rootPos).Magnitude <= HeatAuraRadius then
				table.insert(targets, character)
			end
		end
	end

	if HeatAuraMode == "Single" then
		return targets[1] and { targets[1] } or {}
	elseif HeatAuraMode == "Multi" then
		local limited = {}
		for i = 1, math.min(10, #targets) do
			table.insert(limited, targets[i])
		end
		return limited
	end
	return {}
end

local function fireHvKillaura(targets)
	if not remote4 or #targets == 0 then return false end
	local allSuccess = true
	local coroutines = {}

	for _, target in ipairs(targets) do
		if target and target:FindFirstChild("Head") and target:FindFirstChild("Humanoid") and target.Humanoid.Health > 0 then
			local head = target.Head
			local position = head.Position
			local normal = Vector3.new(0, 1, 0)

			table.insert(coroutines, coroutine.create(function()
				pcall(function()
					remote4:InvokeServer("UpdateLaser", {
						Normal = normal,
						Material = Enum.Material.Air,
						Position = position
					}, {}, 0.1)
				end)

				pcall(function()
					local rootPos = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and LocalPlayer.Character.HumanoidRootPart.Position or position
					local direction = (position - rootPos).Unit
					remote4:InvokeServer("Hit", 100, head, position, direction, Enum.Material.Plastic)
				end)
			end))
		end
	end

	for _, co in ipairs(coroutines) do
		coroutine.resume(co)
	end

	return allSuccess
end

Hvkilaura:Toggle({
	Name = "Hv Kill aura",
	Default = false,
	Flag = "",
	Callback = function(val)
		_G.HvKillaura = val
		if val then
			remote4 = hasCompoundXVision()
			if not remote4 then
				_G.HvKillaura = false
				return
			end
			checkPlayerAlive()
			pcall(function()
				remote4:InvokeServer("ToggleEyes", true)
			end)
			pcall(function()
				remote4:InvokeServer("ToggleLaser", true, {
					Normal = Vector3.new(0, 1, 0),
					Material = Enum.Material.Air,
					RayLength = HeatAuraRadius,
					Position = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and LocalPlayer.Character.HumanoidRootPart.Position or Vector3.new(0, 0, 0)
				}, {}, 0.1)
			end)
		else
			disableHvKillaura()
		end
	end
})

Hvkilaura:Dropdown({
	Name = "Options",
	Default = "Single",
	Content = { "Single", "Multi" },
	Flag = "",
	Callback = function(value)
		HeatAuraMode = value
	end
})

Hvkilaura:Slider({
	Name = "Hv kill aura Distance",
	Flag = "",
	Min = 1,
	Max = 125,
	Default = 25,
	Decimal = 1,
	Callback = function(Value)
		HeatAuraRadius = Value
	end
})

LocalPlayer.CharacterAdded:Connect(function()
	isPlayerAlive = true
	if _G.HvKillaura then
		remote4 = hasCompoundXVision()
		if remote4 then
			pcall(function()
				remote4:InvokeServer("ToggleEyes", true)
			end)
			pcall(function()
				remote4:InvokeServer("ToggleLaser", true, {
					Normal = Vector3.new(0, 1, 0),
					Material = Enum.Material.Air,
					RayLength = HeatAuraRadius,
					Position = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and LocalPlayer.Character.HumanoidRootPart.Position or Vector3.new(0, 0, 0)
				}, {}, 0.1)
			end)
		end
	end
end)

LocalPlayer.CharacterRemoving:Connect(function()
	isPlayerAlive = false
	if _G.HvKillaura then
		disableHvKillaura()
	end
end)

Workspace.Characters.ChildAdded:Connect(function()
	if _G.HvKillaura and isPlayerAlive then
		remote4 = hasCompoundXVision()
	end
end)

checkPlayerAlive()

task.spawn(function()
	while task.wait(0.02) do
		if _G.HvKillaura and isPlayerAlive then
			local targets = getAllTargets()
			if #targets > 0 then
				fireHvKillaura(targets)
			end
		end
	end
end)

local Ragebot = {
	Enabled = false,
	TeamCheck = false,
	Cooldown = 1 / 30,
	LastShot = 0,
	FireRate = 30,
	MaxDistance = 100,
	CurrentDistance = 100,
	DownedCheck = false,
	PlayHitSound = true,
	TargetLock = "",
	LockedPlayer = nil,
	TargetPart = "Head",
}

local TracerTextures = {
	["Flohaxx"] = "rbxassetid://446111271",
	["Lighting"] = "rbxassetid://7216850022",
	["Laser"] = "rbxassetid://7136858729",
	["Twisted Energy"] = "rbxassetid://7071778278",
	["Anime Lazer"] = "rbxassetid://17441065350",
	["Interstellar"] = "rbxassetid://128372145766358",
	["Arrow"] = "rbxassetid://1274378728",
	["Minecraft"] = "rbxassetid://152410036",
	["Alien Energy Ray"] = "rbxassetid://6091341618",
	["Energy Ray"] = "rbxassetid://13832105797",
	["Matrix"] = "rbxassetid://15097610754",
	["Cartoony Eletric"] = "rbxassetid://18722421816",
}

local Tracers = {
	Enabled = false,
	ActiveTraces = {},
	Duration = 3,
	Color = Color3.fromRGB(255, 0, 0),
	TextureID = TracerTextures["Flohaxx"]
}

local Whitelist = {
	Enabled = true,
	Names = {},
	Prefixes = {}
}

local function PlayHitSound()
	local sound = Instance.new("Sound")
	sound.SoundId = selectedSoundId
	sound.Volume = 1
	sound.PlayOnRemove = true
	sound.Parent = workspace
	sound:Destroy()
end

local function GenerateID(length)
	local charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890"
	local str = ""
	for _ = 1, length do
		local rand = math.random(1, #charset)
		str = str .. charset:sub(rand, rand)
	end
	return str
end

local function CreateTracer(target)
	if not Tracers.Enabled or not LocalPlayer.Character then return end

	local head = LocalPlayer.Character:FindFirstChild("Head")
	if not head or not target then return end

	local function createPart(cframe)
		local part = Instance.new("Part")
		part.Size = Vector3.new(0.1, 0.1, 0.1)
		part.Transparency = 1
		part.Anchored = true
		part.CanCollide = false
		part.CFrame = cframe
		part.Parent = workspace
		return part
	end

	local startPart = createPart(head.CFrame)
	local endPart = createPart(CFrame.new(target.Position))

	local att0 = Instance.new("Attachment", startPart)
	att0.Position = Vector3.zero
	att0.Name = "StartAttachment"

	local att1 = Instance.new("Attachment", endPart)
	att1.Position = Vector3.zero
	att1.Name = "EndAttachment"

	local beam = Instance.new("Beam")
	beam.Attachment0 = att0
	beam.Attachment1 = att1
	beam.FaceCamera = true
	beam.Width0 = 3
	beam.Width1 = 3
	beam.Color = ColorSequence.new(Tracers.Color)
	beam.LightEmission = 1
	beam.LightInfluence = 0
	beam.Transparency = NumberSequence.new(0)
	beam.Texture = Tracers.TextureID
	beam.TextureSpeed = 2
	beam.TextureLength = 1
	beam.Parent = startPart

	table.insert(Tracers.ActiveTraces, {start = startPart, endp = endPart})

	task.spawn(function()
		local t = 0
		local step = 0.05
		while t < Tracers.Duration do
			local alpha = t / Tracers.Duration
			beam.Transparency = NumberSequence.new(alpha)
			t += step
			task.wait(step)
		end
		if startPart then startPart:Destroy() end
		if endPart then endPart:Destroy() end
	end)
end

local function AddToWhitelist(entry)
	if entry == "" then return end
	if tonumber(entry) then
		table.insert(Whitelist.Prefixes, entry)
	elseif entry:sub(-1) == "*" then
		table.insert(Whitelist.Prefixes, entry:sub(1, -2))
	end
	Whitelist.Names[entry] = true
end

local function IsWhitelisted(player)
	if not Whitelist.Enabled then return false end
	if Whitelist.Names[player.Name] then return true end

	local userId = tostring(player.UserId)
	for _, prefix in ipairs(Whitelist.Prefixes) do
		if tonumber(prefix) and userId:find("^" .. prefix) then return true end
		if player.Name:lower():find("^" .. prefix:lower()) or player.DisplayName:lower():find("^" .. prefix:lower()) then
			return true
		end
	end
	return false
end

local function IsTeammate(player)
	if not Ragebot.TeamCheck then return false end
	return LocalPlayer.Team and player.Team and LocalPlayer.Team == player.Team
end

local function GetTarget()
	local myHRP = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
	if not myHRP then return nil end

	if Ragebot.LockedPlayer then
		local plr = Ragebot.LockedPlayer
		local char = plr.Character
		if char then
			local part = char:FindFirstChild("HumanoidRootPart")
			local hum = char:FindFirstChildOfClass("Humanoid")
			if part and hum and hum.Health > 0 and not IsWhitelisted(plr) and not IsTeammate(plr) then
				if not (Ragebot.DownedCheck and hum.Health <= 15) then
					local dist = (part.Position - myHRP.Position).Magnitude
					local targetHitbox = char:FindFirstChild(Ragebot.TargetPart) or part
					if dist <= Ragebot.CurrentDistance and targetHitbox then
						if not Ragebot.VisibleCheck or IsVisible(Camera.CFrame.Position, targetHitbox.Position) then
							return plr
						end
					end
				end
			end
		end
		Ragebot.LockedPlayer = nil
	end

	local closest, minDist = nil, Ragebot.CurrentDistance
	for _, plr in ipairs(Players:GetPlayers()) do
		if plr == LocalPlayer then continue end
		local char = plr.Character
		if not char then continue end

		local part = char:FindFirstChild("HumanoidRootPart")
		local hum = char:FindFirstChildOfClass("Humanoid")
		if part and hum and hum.Health > 0 and not IsWhitelisted(plr) and not IsTeammate(plr) then
			if not (Ragebot.DownedCheck and hum.Health <= 15) then
				local dist = (part.Position - myHRP.Position).Magnitude
				local targetHitbox = char:FindFirstChild(Ragebot.TargetPart) or part
				if dist < minDist and targetHitbox then
					if not Ragebot.VisibleCheck or IsVisible(Camera.CFrame.Position, targetHitbox.Position) then
						closest = plr
						minDist = dist
					end
				end
			end
		end
	end
	return closest
end

function ShootTarget(plr)
	if not plr or not plr.Character then return end
	local targetPart = plr.Character:FindFirstChild(Ragebot.TargetPart) or plr.Character:FindFirstChild("Head")
	if not targetPart then return end

	local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
	if not tool then return end

	local values = tool:FindFirstChild("Values")
	if not values then return end

	local ammo = values:FindFirstChild("SERVER_Ammo")
	if not ammo or ammo.Value <= 0 then return end

	if Tracers.Enabled then
		CreateTracer(targetPart)
	end

	local direction = (targetPart.Position - Camera.CFrame.Position).Unit
	local randomId = GenerateID(30) .. "0"

	ReplicatedStorage.Events.GNX_S:FireServer(tick(), randomId, tool, "FDS9I83", Camera.CFrame.Position, { direction }, false)
	ReplicatedStorage.Events.ZFKLF__H:FireServer("üßà", tool, randomId, 1, targetPart, targetPart.Position, direction)

	if tool:FindFirstChild("Hitmarker") then
		tool.Hitmarker:Fire(targetPart)
		PlayHitSound()
	end
end

task.spawn(function()
	while true do
		if Ragebot.Enabled and tick() - Ragebot.LastShot >= Ragebot.Cooldown then
			local target = GetTarget()
			if target then
				ShootTarget(target)
				Ragebot.LastShot = tick()
			end
		end
		task.wait()
	end
end)

rage:Toggle({
	Name = "Enabled RageBot",
	Default = false,
	Flag = "RagebotEnabled",
	Callback = function(state)
		Ragebot.Enabled = state
	end
})

rage:Toggle({
	Name = "Team Check",
	Default = false,
	Flag = "RagebotTeamCheck",
	Callback = function(state)
		Ragebot.TeamCheck = state
	end
})

rage:Toggle({
	Name = "HitSound",
	Default = true,
	Flag = "RagebotHitSound",
	Callback = function(state)
		Ragebot.PlayHitSound = state
	end
})

rage:Toggle({
	Name = "Downed Check",
	Default = false,
	Flag = "RagebotDownedCheck",
	Callback = function(state)
		Ragebot.DownedCheck = state
	end
})

rage:Toggle({
	Name = "Bullet Tracer",
	Default = false,
	Flag = "RagebotBulletTracer",
	Callback = function(state)
		Tracers.Enabled = state
	end
})

rage:Slider({
	Name = "Tracer Lifetime",
	Min = 1,
	Max = 5,
	Default = 3,
	Decimal = 1,
	Flag = "RagebotTracerLifetime",
	Callback = function(val)
		Tracers.Duration = val
	end
})

local Color = rage:Label({Message = "Bullet tracer color"})
Color:ColorPicker({
	Name = "Bullet tracer color",
	Default = Tracers.Color,
	Alpha = 1,
	Flag = "RagebotTracerColor",
	Callback = function(val)
		Tracers.Color = val
	end
})

rage:Dropdown({
	Name = "Tracer Texture",
	Flag = "RagebotTracerTexture",
	Content = {"Form Flohaxx", "Lighting", "Laser", "Twisted Energy", "Anime Lazer", "Interstellar", "Arrow", "Minecraft", "Alien Energy Ray", "Energy Ray", "Matrix", "Cartoony Eletric"},
	Default = "Form Flohaxx",
	Callback = function(option)
		if TracerTextures[option] then
			Tracers.TextureID = TracerTextures[option]
		end
	end
})

rage:Slider({
	Name = "Fire Rate",
	Min = 1,
	Max = 25,
	Default = 3,
	Decimal = 1,
	Flag = "RagebotFireRate",
	Callback = function(val)
		Ragebot.FireRate = val
		Ragebot.Cooldown = 1 / val
	end
})

rage:Dropdown({
	Name = "Target Part",
	Flag = "RagebotTargetPart",
	Content = {"Head", "UpperTorso", "LowerTorso"},
	Default = "Head",
	Callback = function(option)
		Ragebot.TargetPart = option
	end
})

rage:Dropdown({
	Name = "Hit Sound",
	Flag = "",
	Content = {
		"Bubble",
		"Classic",
		"Minecraft Critical Hit Sound",
		"Minecraft Sound Successful Bow Hit Ding",
		"osu hit sound",
		"item asylum hit sound",
		"Never Lose hit sound",
		"ping pong hit",
		"Godlike",
		"pow"
		
	},
	Default = "Bubble",
	Callback = function(option)
		if option == "Bubble" then
			selectedSoundId = "rbxassetid://11969758065"
		elseif option == "Classic" then
			selectedSoundId = "rbxassetid://4817809188"
		elseif option == "Minecraft Critical Hit Sound" then
			selectedSoundId = "rbxassetid://8458185621"
		elseif option == "Minecraft Sound Successful Bow Hit Ding" then
			selectedSoundId = "rbxassetid://13547800911"
		elseif option == "osu hit sound" then
			selectedSoundId = "rbxassetid://7172607676"
		elseif option == "item asylum hit sound" then
			selectedSoundId = "rbxassetid://7217342273"
		elseif option == "Never Lose hit sound" then
			selectedSoundId = "rbxassetid://6607113255"
		elseif option == "ping pong hit" then
			selectedSoundId = "rbxassetid://7356663377"
		elseif option == "Godlike" then
			selectedSoundId = "7463103082"
		elseif option == "pow" then
			selectedSoundId = "3516546035"
		end
	end
})

local Debris = workspace:WaitForChild("Debris")
local VParts = Debris:WaitForChild("VParts")
local tween = game:GetService("TweenService")
local input = game:GetService("UserInputService")
local run = game:GetService("RunService")

local rocketEnabled = false
local rocketSpeed = 200
local selectedWeapon = "RPG-7"
local Forward, Sideways, Break = 0, 0, false

local weaponToProjectile = {
	["RPG-7"] = {"RPG_Rocket"},
	["RPG-29"] = {"RPG_Rocket"},
	["FireworkLauncher"] = {"FireworkLauncher_Rocket"},
	["AT4"] = {"AT4_Rocket"},
	["RPG-18"] = {"Rpg18"},
	["SBL-MK3"] = {"SBL_Rocket"},
	["HL-MK3"] = {"Hallows_Rocket3"},
	["HL-MK2"] = {"Hallows_Rocket2"},
	["HallowsLauncher"] = {"Hallows_Rocket"},
	["M320-1"] = {"GrenadeLauncherGrenade"},
	["SCAR-H-X"] = {"GrenadeLauncherGrenade"},
}

local weaponList = {"All"}
for weaponName in pairs(weaponToProjectile) do
	table.insert(weaponList, weaponName)
end

Control:Toggle({
	Name = "Enabled Rpg Control",
	Default = false,
	Flag = "",
	Callback = function(val)
		rocketEnabled = val
		if not val and me.Character then
			Forward, Sideways, Break = 0, 0, false
			local HRP = me.Character:FindFirstChild("HumanoidRootPart")
			if HRP then HRP.Anchored = false end
			camera.CameraSubject = me.Character:FindFirstChild("Humanoid")
		end
	end
})

Control:Slider({
	Name = "Speed",
	Min = 1,
	Max = 500,
	Default = 250,
	Decimal = 1,
	Flag = "",
	Callback = function(val)
		rocketSpeed = val
	end
})

Control:Dropdown({
	Name = "explosion Guns",
	Flag = "",
	Content = weaponList,
	Default = "all",
	Callback = function(option)
		selectedWeapon = option
	end
})


input.InputBegan:Connect(function(Key)
	if Key.KeyCode == Enum.KeyCode.W then Forward = 1
	elseif Key.KeyCode == Enum.KeyCode.S then Forward = -1
	elseif Key.KeyCode == Enum.KeyCode.D then Sideways = 1
	elseif Key.KeyCode == Enum.KeyCode.A then Sideways = -1 end
end)

input.InputEnded:Connect(function(Key)
	if Key.KeyCode == Enum.KeyCode.W or Key.KeyCode == Enum.KeyCode.S then Forward = 0
	elseif Key.KeyCode == Enum.KeyCode.D or Key.KeyCode == Enum.KeyCode.A then Sideways = 0 end
end)

VParts.ChildAdded:Connect(function(Projectile)
	if not rocketEnabled then return end
	task.wait()

	local validProjectiles = {}
	if selectedWeapon == "All" then
		for _, list in pairs(weaponToProjectile) do
			for _, name in ipairs(list) do
				table.insert(validProjectiles, name)
			end
		end
	else
		validProjectiles = weaponToProjectile[selectedWeapon] or {}
		if not me.Character or not me.Character:FindFirstChild(selectedWeapon) then return end
	end

	for _, projName in ipairs(validProjectiles) do
		if Projectile.Name == projName then
			camera.CameraSubject = Projectile
			local HRP = me.Character:FindFirstChild("HumanoidRootPart")
			if HRP then HRP.Anchored = true end

			pcall(function()
				if Projectile:FindFirstChild("BodyForce") then Projectile.BodyForce:Destroy() end
				if Projectile:FindFirstChild("BodyAngularVelocity") then Projectile.BodyAngularVelocity:Destroy() end
				if Projectile:FindFirstChild("RotPart") and Projectile.RotPart:FindFirstChild("BodyAngularVelocity") then
					Projectile.RotPart.BodyAngularVelocity:Destroy()
				end
				if Projectile:FindFirstChild("Sound") then Projectile.Sound:Destroy() end
			end)

			local BV = Instance.new("BodyVelocity", Projectile)
			BV.MaxForce = Vector3.new(1e9, 1e9, 1e9)
			BV.Velocity = Vector3.new()

			local BG = Instance.new("BodyGyro", Projectile)
			BG.P = 9e4
			BG.MaxTorque = Vector3.new(1e9, 1e9, 1e9)

			task.spawn(function()
				while Projectile and Projectile.Parent and rocketEnabled and me.Character and me.Character:FindFirstChild("HumanoidRootPart") do
					run.RenderStepped:Wait()
					tween:Create(BV, TweenInfo.new(0), {
						Velocity = ((camera.CFrame.LookVector * Forward) + (camera.CFrame.RightVector * Sideways)) * rocketSpeed
					}):Play()
					BG.CFrame = camera.CFrame
					local targetCFrame = Projectile.CFrame * CFrame.new(0, 1, 1)
					camera.CFrame = camera.CFrame:Lerp(targetCFrame + Vector3.new(0, 5, 0), 0.1)

					if Break or not Projectile.Parent then
						Break = false
						camera.CameraSubject = me.Character:FindFirstChildOfClass("Humanoid")
						local HRP = me.Character:FindFirstChild("HumanoidRootPart")
						if HRP then HRP.Anchored = false end
						break
					end
				end

				camera.CameraSubject = me.Character:FindFirstChildOfClass("Humanoid")
				local HRP = me.Character:FindFirstChild("HumanoidRootPart")
				if HRP then HRP.Anchored = false end
			end)
			break
		end
	end
end)

Debris.ChildAdded:Connect(function(Result)
	task.wait()
	if not me.Character then return end
	pcall(function()
		local tool = me.Character:FindFirstChildOfClass("Tool")
		local explosionNames = {
			["RPG-7"] = {"RPG_Explosion_Long", "RPG_Explosion_Short"},
			["M320-1"] = {"GL_Explosion_Long", "GL_Explosion_Short"},
			["SCAR-H-X"] = {"GL_Explosion_Long", "GL_Explosion_Short"},
			["SBL-MK3"] = {"SBL_Explosion"},
			["HL-MK3"] = {"Hallows_Explosion2_Long", "Hallows_Explosion2_Short"},
			["HL-MK2"] = {"Hallows_Explosion"},
			["FireworkLauncher"] = {"Firework_Explosion"},
			["HallowsLauncher"] = {"Hallows_Explosion"},
			["RPG-G"] = {"VortexExplosion"},
			["AT4"] = {"Panzer_Explosion_Long", "Panzer_Explosion_Short"},
			["RPG-18"] = {"BigExplosion2"},
			["RPG-29"] = {"Panzer_Explosion_Long", "Panzer_Explosion_Short"},
		}

		for weapon, explosions in pairs(explosionNames) do
			if me.Character:FindFirstChild(weapon) then
				for _, name in pairs(explosions) do
					if Result.Name == name then
						Break = true
						task.wait(1)
						Break = false
					end
				end
			end
		end
	end)
end)


ESPSection:Toggle({
	Name = "Enabled",
	Default = false,
	Flag = "esp_enabled",
	Callback = function(state)
		esp.enabled = state
	end
})

ESPSection:Toggle({
	Name = "Team Check",
	Default = false,
	Flag = "esp_teamcheck",
	Callback = function(state)
		esp.teamcheck = state
	end
})

ESPSection:Toggle({
	Name = "Box",
	Default = false,
	Flag = "esp_box",
	Callback = function(state)
		esp.box[1] = state
	end
})

ESPSection:Toggle({
	Name = "Box Fill",
	Default = false,
	Flag = "esp_boxfill",
	Callback = function(state)
		esp.boxfill[1] = state
	end
})

ESPSection:Toggle({
	Name = "Tracer",
	Default = false,
	Flag = "esp_tracer",
	Callback = function(state)
		esp.tracer[1] = state
	end
})

ESPSection:Toggle({
	Name = "Chams",
	Default = false,
	Flag = "esp_chams",
	Callback = function(state)
		esp.chams[1] = state
	end
})

ESPSection:Toggle({
	Name = "Skeleton",
	Default = false,
	Flag = "esp_skeleton",
	Callback = function(state)
		esp.skeleton[1] = state
	end
})

ESPSection:Toggle({
	Name = "Arrow",
	Default = false,
	Flag = "esp_arrow",
	Callback = function(state)
		esp.arrow[1] = state
	end
})

ESPSection:Toggle({
	Name = "Angle Lines",
	Default = false,
	Flag = "esp_angle",
	Callback = function(state)
		esp.angle[1] = state
	end
})

ESPSection:Toggle({
	Name = "Outline",
	Default = true,
	Flag = "esp_outline",
	Callback = function(state)
		esp.outline[1] = state
	end
})

ESPSection:Toggle({
	Name = "Show Name",
	Default = false,
	Flag = "esp_show_name",
	Callback = function(state)
		esp.textlayout['name'].enabled = state
	end
})

ESPSection:Toggle({
	Name = "Show Distance",
	Default = false,
	Flag = "esp_show_distance",
	Callback = function(state)
		esp.textlayout['distance'].enabled = state
	end
})

ESPSection:Toggle({
	Name = "Show Health Text",
	Default = false,
	Flag = "esp_show_health_text",
	Callback = function(state)
		esp.textlayout['health'].enabled = state
	end
})

ESPSection:Toggle({
	Name = "Health Bar",
	Default = false,
	Flag = "esp_healthbar",
	Callback = function(state)
		esp.barlayout['health'].enabled = state
	end
})

ESPDropdowns:Dropdown({
	Name = "Bar Position",
	Flag = "bar_pos",
	Content = {"top", "bottom", "left", "right"},
	Default = "left",
	Callback = function(option)
		esp.barlayout.health.pos = option
	end
})

ESPDropdowns:Dropdown({
	Name = "Distance Position",
	Flag = "distance_pos",
	Content = {"top", "bottom", "left", "right"},
	Default = "bottom",
	Callback = function(option)
		esp.textlayout.distance.pos = option
	end
})

ESPDropdowns:Dropdown({
	Name = "Name Position",
	Flag = "name_pos",
	Content = {"top", "bottom", "left", "right"},
	Default = "top",
	Callback = function(option)
		esp.textlayout.name.pos = option
	end
})

local NameLbl = ESPDropdowns:Label({Message = "Name Color"})
NameLbl:ColorPicker({
	Name = "Name Color",
	Default = Color3.fromRGB(255, 255, 255),
	Alpha = 1,
	Flag = "name_color",
	Callback = function(val)
		esp.textlayout.name.color = val
	end
})

local DistanceLbl = ESPDropdowns:Label({Message = "Distance Color"})
DistanceLbl:ColorPicker({
	Name = "Distance Color",
	Default = Color3.fromRGB(255, 255, 255),
	Alpha = 1,
	Flag = "distance_color",
	Callback = function(val)
		esp.textlayout.distance.color = val
	end
})

local Chams1Lbl = ESPDropdowns:Label({Message = "Chams Color 1"})
Chams1Lbl:ColorPicker({
	Name = "Chams Color 1",
	Default = Color3.fromRGB(255, 255, 255),
	Alpha = 1,
	Flag = "chams_color_1",
	Callback = function(val)
		esp.chams[2] = val
	end
})

local Chams2Lbl = ESPDropdowns:Label({Message = "Chams Color 2"})
Chams2Lbl:ColorPicker({
	Name = "Chams Color 2",
	Default = Color3.fromRGB(255, 255, 255),
	Alpha = 1,
	Flag = "chams_color_2",
	Callback = function(val)
		esp.chams[3] = val
	end
})

local TracerLbl = ESPDropdowns:Label({Message = "Tracer Color"})
TracerLbl:ColorPicker({
	Name = "Tracer Color",
	Default = Color3.fromRGB(255, 255, 255),
	Alpha = 1,
	Flag = "tracer_color",
	Callback = function(val)
		esp.tracer[2] = val
	end
})

local HealthTextLbl = ESPDropdowns:Label({Message = "Health Text Color"})
HealthTextLbl:ColorPicker({
	Name = "Health Text Color",
	Default = Color3.fromRGB(255, 255, 255),
	Alpha = 1,
	Flag = "health_text_color",
	Callback = function(val)
		esp.textlayout.health.color = val
	end
})

local AngleLbl = ESPDropdowns:Label({Message = "View Angle Color"})
AngleLbl:ColorPicker({
	Name = "View Angle Color",
	Default = Color3.fromRGB(255, 255, 255),
	Alpha = 1,
	Flag = "view_angle_color",
	Callback = function(val)
		esp.angle[2] = val
	end
})

local ArrowLbl = ESPDropdowns:Label({Message = "Arrow Color"})
ArrowLbl:ColorPicker({
	Name = "Arrow Color",
	Default = Color3.fromRGB(255, 255, 255),
	Alpha = 1,
	Flag = "arrow_color",
	Callback = function(val)
		esp.arrow[2] = val
	end
})

local SkeletonLbl = ESPDropdowns:Label({Message = "Skeleton Color"})
SkeletonLbl:ColorPicker({
	Name = "Skeleton Color",
	Default = Color3.fromRGB(255, 255, 255),
	Alpha = 1,
	Flag = "skeleton_color",
	Callback = function(val)
		esp.skeleton[2] = val
	end
})

local OutlineLbl = ESPDropdowns:Label({Message = "Outline Color"})
OutlineLbl:ColorPicker({
	Name = "Outline Color",
	Default = Color3.fromRGB(0, 0, 0),
	Alpha = 1,
	Flag = "outline_color",
	Callback = function(val)
		esp.outline[2] = val
	end
})

local BoxLbl = ESPDropdowns:Label({Message = "Box Color"})
BoxLbl:ColorPicker({
	Name = "Box Color",
	Default = Color3.fromRGB(255, 255, 255),
	Alpha = 1,
	Flag = "box_color",
	Callback = function(val)
		esp.box[2] = val
	end
})

local BoxFillLbl = ESPDropdowns:Label({Message = "Box Fill Color"})
BoxFillLbl:ColorPicker({
	Name = "Box Fill Color",
	Default = Color3.fromRGB(255, 255, 255),
	Alpha = 1,
	Flag = "box_fill_color",
	Callback = function(val)
		esp.boxfill[2] = val
	end
})


local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Debris = game:GetService("Debris")
local Workspace = game:GetService("Workspace")

local player = Players.LocalPlayer
local mouse = player:GetMouse()

local Settings = {
	Enabled = true,
	Color = Color3.new(1, 0, 0),
	Transparency = 0.3,
	TextureMode = Enum.TextureMode.Wrap,
}

local BeamSettings = {
	Width0 = 0.2,
	Width1 = 0.2
}

local wallbangEnabled = false
local maxTracers = 25
local activeTracers = {}

BulletTracer:Toggle({
	Name = "Enable Bullet Tracer",
	Default = false,
	Flag = "bullet_tracer_enabled",
	Callback = function(state)
		Settings.Enabled = state
	end
})

BulletTracer:Label({Message = "Tracer Color"}):ColorPicker({
	Name = "TracerColor",
	Default = Color3.fromRGB(255, 255, 255),
	Alpha = 1,
	Flag = "tracer_color",
	Callback = function(col)
		Settings.Color = col
	end
})

BulletTracer:Slider({
	Name = "Width 0",
	Min = 0.01,
	Max = 5,
	Default = 1,
	Decimals = 0.01,
	Flag = "beam_width0",
	Callback = function(val)
		BeamSettings.Width0 = val
	end
})

BulletTracer:Slider({
	Name = "Width 1",
	Min = 0.01,
	Max = 5,
	Default = 1,
	Decimals = 0.01,
	Flag = "beam_width1",
	Callback = function(val)
		BeamSettings.Width1 = val
	end
})

BulletTracer:Dropdown({
	Name = "Beam Texture Mode",
	Items = { "Wrap", "Stretch", "Static" },
	Flag = "beam_texture_mode",
	Callback = function(mode)
		Settings.TextureMode = Enum.TextureMode[mode]
	end
})

local function findWeaponHandle(charFolder)
	if not charFolder then return nil end
	for _, tool in ipairs(charFolder:GetChildren()) do
		if tool:IsA("Model") and tool:FindFirstChild("WeaponHandle") then
			return tool.WeaponHandle
		end
	end
	return nil
end

local function createTracer(startPos, endPos)
	if not Settings.Enabled or not startPos or not endPos then return end

	while #activeTracers >= maxTracers do
		local oldest = table.remove(activeTracers, 1)
		if oldest and oldest.beamHolder and oldest.beamHolder:IsDescendantOf(game) then
			oldest.beamHolder:Destroy()
		end
	end

	local beamPart = Instance.new("Part")
	beamPart.Name = "BeamHolder"
	beamPart.Anchored = true
	beamPart.CanCollide = false
	beamPart.Transparency = 1
	beamPart.Size = Vector3.new(1, 1, 1)
	beamPart.CFrame = CFrame.new((startPos + endPos) / 2)
	beamPart.Parent = workspace

	local attachment0 = Instance.new("Attachment", beamPart)
	attachment0.WorldPosition = startPos

	local attachment1 = Instance.new("Attachment", beamPart)
	attachment1.WorldPosition = endPos

	local beam = Instance.new("Beam")
	beam.Attachment0 = attachment0
	beam.Attachment1 = attachment1
	beam.Color = ColorSequence.new(Settings.Color)
	beam.LightEmission = 1
	beam.Width0 = BeamSettings.Width0
	beam.Width1 = BeamSettings.Width1
	beam.Texture = "rbxassetid://9150663556"
	beam.TextureLength = 2
	beam.TextureMode = Settings.TextureMode
	beam.FaceCamera = true
	beam.Transparency = NumberSequence.new(Settings.Transparency)
	beam.Parent = beamPart

	table.insert(activeTracers, {beamHolder = beamPart})

	coroutine.wrap(function()
		task.wait(1)
		for t = 0, 1, 0.05 do
			if beam then
				beam.Transparency = NumberSequence.new(t)
			end
			task.wait(0.025)
		end
		if beamPart and beamPart.Parent then
			beamPart:Destroy()
		end
	end)()

	Debris:AddItem(beamPart, 1.25)
end

local isShooting = false
local lastShotTime = 0
local shotCooldown = 0.05

UserInputService.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		isShooting = true
		lastShotTime = tick()

		local Character = player.Character or player.CharacterAdded:Wait()
		local charFolder = Workspace:FindFirstChild("Characters")
		if not charFolder then return end

		local myChar = charFolder:FindFirstChild(player.Name)
		if not myChar then return end

		local weaponHandle = findWeaponHandle(myChar)
		if not weaponHandle then return end

		local startPos = weaponHandle.Position
		local endPos = mouse.Hit and mouse.Hit.Position or (startPos + Vector3.new(0, 0, -100))

		if wallbangEnabled then
			createTracer(startPos, endPos)
		else
			local rayParams = RaycastParams.new()
			rayParams.FilterDescendantsInstances = {Character}
			rayParams.FilterType = Enum.RaycastFilterType.Blacklist

			local result = Workspace:Raycast(startPos, (endPos - startPos).Unit * 1000, rayParams)
			if result then
				if result.Instance and (result.Instance.Parent:FindFirstChild("Humanoid") or result.Instance.Name == "BulletHole") then
					createTracer(startPos, result.Position)
				end
			end
		end
	end
end)

UserInputService.InputEnded:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		isShooting = false
	end
end)

Workspace.Debris.ChildAdded:Connect(function(child)
	if not Settings.Enabled then return end
	if child:IsA("Part") and child.Name == "BulletHole" then
		if not isShooting and (tick() - lastShotTime > shotCooldown) then return end

		local Character = player.Character or player.CharacterAdded:Wait()
		local charFolder = Workspace:FindFirstChild("Characters")
		if not charFolder then return end

		local myChar = charFolder:FindFirstChild(player.Name)
		if not myChar then return end

		local weaponHandle = findWeaponHandle(myChar)
		if not weaponHandle then return end

		local startPos = weaponHandle.Position
		local endPos = child.Position

		if (startPos - endPos).Magnitude < 1000 then
			createTracer(startPos, endPos)
			lastShotTime = tick()
		end
	end
end)

local functions = {}
functions.instant_reloadF = false

GunMds:Toggle({
	Name = "Auto Reload",
	Flag = "",
	Default = false,
	Callback = function(Value)
		functions.instant_reloadF = Value
		if Value then
			spawn(instantreloadL)
		end

	end
})

instantreloadL = function()
	local gunR_remote = game:GetService("ReplicatedStorage").Events["GNX_R"]
	local connections = {}
	local toolConn
	local charConn

	local function setupTool(tool)
		if not tool or not tool:FindFirstChild("IsGun") then return end
		local values = tool:FindFirstChild("Values")
		if not values then return end
		local serverAmmo = values:FindFirstChild("SERVER_Ammo")
		local storedAmmo = values:FindFirstChild("SERVER_StoredAmmo")

		if storedAmmo then
			local conn1 = storedAmmo:GetPropertyChangedSignal("Value"):Connect(function()
				if functions.instant_reloadF and storedAmmo.Value ~= 0 then
					gunR_remote:FireServer(tick(), "KLWE89U0", tool)
				end
			end)
			table.insert(connections, conn1)
			if storedAmmo.Value ~= 0 and functions.instant_reloadF then
				gunR_remote:FireServer(tick(), "KLWE89U0", tool)
			end
		end

		if serverAmmo then
			local conn2 = serverAmmo:GetPropertyChangedSignal("Value"):Connect(function()
				if functions.instant_reloadF and storedAmmo and storedAmmo.Value ~= 0 then
					gunR_remote:FireServer(tick(), "KLWE89U0", tool)
				end
			end)
			table.insert(connections, conn2)
		end
	end

	local function cleanupConnections()
		for _, conn in pairs(connections) do
			if conn.Connected then
				conn:Disconnect()
			end
		end
		connections = {}
	end

	local function setupCharacter(char)
		cleanupConnections()
		setupTool(char:FindFirstChildOfClass("Tool"))
		if toolConn then
			toolConn:Disconnect()
		end
		toolConn = char.ChildAdded:Connect(function(obj)
			if obj:IsA("Tool") and obj:FindFirstChild("IsGun") then
				setupTool(obj)
			end
		end)
	end

	if LocalPlayer.Character then
		setupCharacter(LocalPlayer.Character)
	end

	if charConn then
		charConn:Disconnect()
	end
	charConn = LocalPlayer.CharacterAdded:Connect(function(char)
		setupCharacter(char)
	end)

	while functions.instant_reloadF do
		task.wait(0.1)
	end

	cleanupConnections()
	if charConn then charConn:Disconnect() end
	if toolConn then toolConn:Disconnect() end
end

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local Animations = {
	["Fake-BlindAnim"] = "14694544863",
	["Fake-Crounch"] = "14694501365",
	["Fake-OpenLoop"] = "14694544925",
	["Fake-PSlide"] = "12323412326",
	["TorzoFreeze"] = "13084367111",
	["Carpet"] = "282574440",
	["Fake-DoorHit"] = "14894406295",
	["Fake-Finish"] = "14894394657",
	["Dance4"] = "14849677565",
	["Dance5"] = "14849684060",
	["Dance6"] = "14849689388",
	["Sit"] = "14849671564",
	["Swim"] = "14694480604",
	["Chorno"] = "134403868024515",
	["Rvvz"] = "93799420437397",
	["None"] = ""
}

local currentTrack = nil
local animEnabled = false
local selectedAnimId = ""

local function PlayAnimation(animationId)
	local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
	local hum = char:FindFirstChildOfClass("Humanoid")
	if not hum then return end

	local animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
	local anim = Instance.new("Animation")
	anim.AnimationId = "rbxassetid://" .. animationId

	local track = animator:LoadAnimation(anim)
	track.Priority = Enum.AnimationPriority.Action
	track.Looped = true
	track:Play()
	return track
end

local function StopAnimation()
	if currentTrack then
		currentTrack:Stop()
		currentTrack = nil
	end
end

local function UpdateAnimation()
	StopAnimation()
	if animEnabled and selectedAnimId ~= "" then
		currentTrack = PlayAnimation(selectedAnimId)
	end
end

local animationNames = {}
for name in pairs(Animations) do
	table.insert(animationNames, name)
end
table.sort(animationNames)

misc:Toggle({
	Name = "Enable Animations",
	Default = false,
	Flag = "EnableAnims",
	Callback = function(Value)
		animEnabled = Value
		UpdateAnimation()
	end
})

misc:Dropdown({
	Name = "Play Animation",
	Default = "None",
	Content = animationNames,
	Flag = "SelectedAnimation",
	Callback = function(selectedName)
		local animId = Animations[selectedName] or ""
		selectedAnimId = animId
		UpdateAnimation()
	end
})




local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
local humanoid = character:WaitForChild("Humanoid")

local enabled = false
local animation = Instance.new("Animation")
animation.AnimationId = "rbxassetid://282574440"
local danceTrack = nil
local heartbeatConnection = nil
local dysenc = {}
local temp = 1
local animpos = 1.755
local underground = -2.6

local function isHiddenBodyEnabled()
	local success, value = pcall(function()
		return Toggles.HiddenBody and Toggles.HiddenBody.Value
	end)
	return success and value
end

local function enableSpoofMethod()
	enabled = true
	danceTrack = humanoid:LoadAnimation(animation)
	danceTrack.Looped = true
	danceTrack.Priority = Enum.AnimationPriority.Action4
	danceTrack:Play(0.1, 1, 0)

	heartbeatConnection = RunService.Heartbeat:Connect(function()
		temp += 1
		if enabled and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
			if danceTrack then
				danceTrack.TimePosition = animpos
			end
			local hrp = player.Character.HumanoidRootPart
			dysenc[1] = hrp.CFrame
			dysenc[2] = hrp.AssemblyLinearVelocity
			local spoofed = hrp.CFrame + Vector3.new(0, underground, 0)
			hrp.CFrame = spoofed

			RunService.RenderStepped:Wait()

			if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
				hrp.CFrame = dysenc[1]
				hrp.AssemblyLinearVelocity = dysenc[2]
			end
		end
	end)
end

local function disableSpoofMethod()
	enabled = false
	if danceTrack then
		danceTrack:Stop()
		danceTrack:Destroy()
		danceTrack = nil
	end
	if heartbeatConnection then
		heartbeatConnection:Disconnect()
		heartbeatConnection = nil
	end
end

local function onCharacterAdded(char)
	character = char
	humanoid = char:WaitForChild("Humanoid")
	humanoidRootPart = char:WaitForChild("HumanoidRootPart")

	if isHiddenBodyEnabled() then
		enableSpoofMethod()
	end

	humanoid.Died:Connect(function()
		disableSpoofMethod()
	end)
end

if player.Character then
	onCharacterAdded(player.Character)
end

player.CharacterAdded:Connect(onCharacterAdded)
player.CharacterRemoving:Connect(function()
	disableSpoofMethod()
end)

misc:Toggle({
	Name = "Hidden Body",
	Default = false,
	Flag = "HiddenBody",
	Callback = function(Value)
		if Value then
			enableSpoofMethod()
		else
			disableSpoofMethod()
		end
	end
})

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local me = Players.LocalPlayer

getgenv().functions = {
	Infstamina = false
}

misc:Toggle({
	Name = "Inf Stamina",
	Default = false,
	Flag = "",
	Callback = function(state)
		functions.Infstamina = state
	end
})

task.spawn(function()
	while true do
		if functions.Infstamina then
			local char = me.Character
			if char then
				local hum = char:FindFirstChild("Humanoid")
				if hum and not hum:GetAttribute("ZSPRN_M") then
					hum:SetAttribute("ZSPRN_M", true)
				end
			end

			me.CharacterAdded:Connect(function(char)
				if functions.Infstamina then
					local hum = char:WaitForChild("Humanoid", 5)
					if hum and not hum:GetAttribute("ZSPRN_M") then
						hum:SetAttribute("ZSPRN_M", true)
					end
				end
			end)
		else
			local char = me.Character
			if char then
				local hum = char:FindFirstChild("Humanoid")
				if hum and hum:GetAttribute("ZSPRN_M") then
					hum:SetAttribute("ZSPRN_M", nil)
				end
			end
		end
		RunService.RenderStepped:Wait()
	end
end)

misc:Toggle({
	Name = "No Fall Damage",
	Default = false,
	Flag = "nofalldamage",
	Callback = function(state)
		functions.Nofalldamage = state
	end
})

task.spawn(function()
	while task.wait() do
		if functions.Nofalldamage then
			if me.Character then
				local ff = Instance.new("ForceField")
				ff.Parent = me.Character
				ff.Visible = false
			end
			me.CharacterAdded:Connect(function(char)
				if functions.Nofalldamage and char and char:WaitForChild("HumanoidRootPart") and char:WaitForChild("Humanoid") then
					local ff = Instance.new("ForceField")
					ff.Parent = char
					ff.Visible = false
				end
			end)
		else
			if me.Character then
				for _, a in pairs(me.Character:GetChildren()) do
					if a:IsA("ForceField") and a.Visible == false then
						a:Destroy()
					end
				end
			end
		end
	end
end)

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local Oppss = {
	SpeedValue = { Value = 50 }
}

local function StartSpeed()
	if not _G.SpeedConnection then
		_G.SpeedConnection = RunService.Heartbeat:Connect(function()
			local c = player.Character
			if c and c:FindFirstChild("Humanoid") and c:FindFirstChild("HumanoidRootPart") then
				local h = c.Humanoid
				local r = c.HumanoidRootPart
				local d = h.MoveDirection

				if h:GetState() ~= Enum.HumanoidStateType.Climbing then
					local velX = d.X * Oppss.SpeedValue.Value
					local velZ = d.Z * Oppss.SpeedValue.Value
					r.Velocity = Vector3.new(velX, r.Velocity.Y, velZ)
				end
			end
		end)
	end
end

local function StopSpeed()
	if _G.SpeedConnection then
		_G.SpeedConnection:Disconnect()
		_G.SpeedConnection = nil
	end
end

local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

local CustomFOV = Camera.FieldOfView

misc3:Slider({
	Name = "Field Of View",
	Min = 30,
	Max = 120,
	Default = 90,
	Decimal = 1,
	Flag = "",
	Callback = function(Value)
		CustomFOV = Value
		Camera.FieldOfView = Value
	end
})

RunService.RenderStepped:Connect(function()
	if Camera.FieldOfView ~= CustomFOV then
		Camera.FieldOfView = CustomFOV
	end
end)


misc3:Toggle({
	Name = "Speed Hack",
	Default = false,
	Flag = "speed_hack",
	Callback = function(state)
		if state then
			StartSpeed()
		else
			StopSpeed()
		end
	end
})

misc3:Slider({
	Name = "Speed Value",
	Min = 16,
	Max = 41,
	Default = 27,
	Decimal = 1,
	Flag = "speed_value",
	Callback = function(value)
		Oppss.SpeedValue.Value = value
	end
})

local player = game.Players.LocalPlayer
local charStats = game:GetService("ReplicatedStorage").CharStats

misc3:Toggle({
	Name = "Fast Acceleration (idk if this Works)",
	Default = false,
	Flag = "FastAccel",
	Callback = function(Value)
		local stats = charStats:FindFirstChild(player.Name)
		if stats then
			stats.AccelerationModifier.Value = Value and 1e100 or 1
			stats.AccelerationModifier2.Value = Value and 1e100 or 1
		end
	end
})

local event = ReplicatedStorage:FindFirstChild("Events"):FindFirstChild("__RZDONL")

local RUNS = {}
local functions = {}
local Methods = {}
local flyspeed = 60

local function fly(hrp)
	if functions.Fly then
		if RUNS.Fly then RUNS.Fly:Disconnect() end

		RUNS.Fly = RunService.RenderStepped:Connect(function()
			local moveVector = Vector3.new(0, 0, 0)

			if UserInputService:IsKeyDown(Enum.KeyCode.W) then
				moveVector = moveVector + (camera.CFrame.LookVector * flyspeed)
			end
			if UserInputService:IsKeyDown(Enum.KeyCode.S) then
				moveVector = moveVector - (camera.CFrame.LookVector * flyspeed)
			end
			if UserInputService:IsKeyDown(Enum.KeyCode.A) then
				moveVector = moveVector - (camera.CFrame.RightVector * flyspeed)
			end
			if UserInputService:IsKeyDown(Enum.KeyCode.D) then
				moveVector = moveVector + (camera.CFrame.RightVector * flyspeed)
			end

			hrp.Velocity = moveVector

			if Methods.Fly == "Bypass" then
				event:FireServer("__---r", Vector3.new(0, 0, 0), hrp.CFrame, false)
			elseif Methods.Fly == "Velocity" then
			end
		end)
	else
		if RUNS.Fly then RUNS.Fly:Disconnect(); RUNS.Fly = nil end
		if hrp then
			hrp.Velocity = Vector3.new(0, 0, 0)
		end
	end
end

local function setupFly(char)
	local hrp = char:WaitForChild("HumanoidRootPart")
	fly(hrp)
end

if me.Character then
	setupFly(me.Character)
end
me.CharacterAdded:Connect(setupFly)


misc3:Toggle({
	Name = "Fly",
	Default = false,
	Flag = "fly_enabled",
	Callback = function(Value)
		functions.Fly = Value
		local char = me.Character
		if char and char:FindFirstChild("HumanoidRootPart") then
			fly(char:FindFirstChild("HumanoidRootPart"))
		end
	end
})

misc3:Dropdown({
	Name = "Fly Method",
	Default = "Bypass",
	Content = {"Bypass", "Normal"},
	Flag = "fly_method",
	Callback = function(choice)
		Methods.Fly = choice
	end
})

misc3:Slider({
	Name = "Fly Speed",
	Min = 20,
	Max = 150,
	Default = 60,
	Flag = "fly_speed",
	Callback = function(val)
		flyspeed = val
	end
})


charStats.ChildAdded:Connect(function(child)
	if child.Name == player.Name then
		task.wait()
		Toggles.FastAccel:SetValue(Toggles.FastAccel.Value)
	end
end)

player.CharacterAdded:Connect(function(char)
	char:WaitForChild("Humanoid").Died:Connect(function()
		task.wait()
		local stats = charStats:FindFirstChild(player.Name)
		if stats then
			Toggles.FastAccel:SetValue(Toggles.FastAccel.Value)
		end
	end)
end)


getgenv().lockpickEasyEnabled = true

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

local function UpdLockPick()
	pcall(function()
		local gui = PlayerGui:FindFirstChild("LockpickGUI")
		if gui then
			local frames = gui:FindFirstChild("MF") and gui.MF:FindFirstChild("LP_Frame") and gui.MF.LP_Frame:FindFirstChild("Frames")
			if frames then
				for i = 1, 3 do
					local frame = frames:FindFirstChild("B" .. i)
					if frame and frame:FindFirstChild("Bar") then
						if getgenv().lockpickEasyEnabled then
							frame.Bar.Size = UDim2.new(0, 35, 0, 500)
						else
							frame.Bar.Size = UDim2.new(0, 35, 0, 30)
						end
					end
				end
			end
		end
	end)
end

PlayerGui.ChildAdded:Connect(function(child)
	if child.Name == "LockpickGUI" then
		task.wait(0.1)
		UpdLockPick()
	end
end)

task.wait(1)
UpdLockPick()

misc4:Toggle({
	Name = "Easy Lock Pick",
	Default = false,
	Flag = "",
	Callback = function(state)
		getgenv().lockpickEasyEnabled = state
		UpdLockPick()
	end
})

_G.AntiFling = true

run.RenderStepped:Connect(function()
	if not _G.AntiFling then return end

	local char = me.Character
	if not char then return end
	local hrp = char:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	local oldVelocity = hrp.Velocity

	for _, part in pairs(char:GetChildren()) do
		if part:IsA("BasePart") then
			part.CanTouch = false
			if part.Velocity.Magnitude > oldVelocity.Magnitude * 3 then
				part.Velocity = Vector3.zero
			end
		end
	end

	for _, player in pairs(plrs:GetPlayers()) do
		if player ~= me then
			local plrChar = player.Character
			if plrChar then
				for _, part in pairs(plrChar:GetChildren()) do
					if part:IsA("BasePart") then
						if part.Velocity.Magnitude > oldVelocity.Magnitude * 3 then
							part.Velocity = Vector3.zero
							part.CanTouch = false
						end
					end
				end
			end
		end
	end
end)

misc:Toggle({
	Name = "Anti Fling",
	Default = false,
	Flag = "AntiFling",
	Callback = function(state)
		_G.AntiFling = state
	end
})

local run = game:GetService("RunService")
local me = game:GetService("Players").LocalPlayer

local RespToggleState = false

misc2:Toggle({
	Name = "Auto Respawn",
	Default = false,
	Flag = "AutoRespawn",
	Callback = function(state)
		RespToggleState = state
	end
})

local deathEvent = game:GetService("ReplicatedStorage"):WaitForChild("Events"):WaitForChild("DeathRespawn")

run.RenderStepped:Connect(function()
	if RespToggleState then
		local char = me.Character
		if char then
			local humanoid = char:FindFirstChildOfClass("Humanoid")
			if humanoid and humanoid.Health <= 0 then
				deathEvent:InvokeServer("KMG4R904")
			end
		end
	end
end)

local player = Players.LocalPlayer
local AutoClaimEnabled = false
local AutoClaimCooldown = false

local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart") or nil

local function updateHRP()
	if player.Character then
		hrp = player.Character:FindFirstChild("HumanoidRootPart")
	end
end

local function GetClosestATM()
	updateHRP()
	if not hrp then return nil end

	local closestATM, minDistance = nil, math.huge
	for _, atmModel in ipairs(Workspace:WaitForChild("Map"):WaitForChild("ATMz"):GetChildren()) do
		local mainPart = atmModel:FindFirstChild("MainPart")
		if mainPart then
			local distance = (hrp.Position - mainPart.Position).Magnitude
			if distance < minDistance then
				minDistance = distance
				closestATM = mainPart
			end
		end
	end
	return closestATM
end

local function AutoClaimAllowance()
	while AutoClaimEnabled do
		updateHRP()
		local dataFolder = ReplicatedStorage:WaitForChild("PlayerbaseData2"):FindFirstChild(player.Name)
		local nextAllowance = dataFolder and dataFolder:FindFirstChild("NextAllowance")

		if nextAllowance and nextAllowance.Value == 0 then
			local atm = GetClosestATM()
			if atm and not AutoClaimCooldown then
				AutoClaimCooldown = true
				ReplicatedStorage:WaitForChild("Events"):WaitForChild("CLMZALOW"):InvokeServer(atm)
				task.wait(0.5)
				AutoClaimCooldown = false
			end
		end
		task.wait(1)
	end
end

player.CharacterAdded:Connect(function(character)
	hrp = character:WaitForChild("HumanoidRootPart")
	if AutoClaimEnabled then
		task.spawn(AutoClaimAllowance)
	end
end)

misc2:Toggle({
	Name = "Auto Claim Allowance",
	Default = false,
	Flag = "AutoClaimAllowance",
	Callback = function(state)
		AutoClaimEnabled = state
		if AutoClaimEnabled then
			task.spawn(AutoClaimAllowance)
		end
	end
})


local AutoBreakSafeCoolDown = false
local AutoBreakRegisterCoolDown = false
local AutoBreakDoorCoolDown = false

local AutoBreakSafeRangeValue = 15
local AutoBreakRegisterRangeValue = 15
local AutoBreakDoorRangeValue = 15

local AutoBreakSafeEnabled = false
local AutoBreakRegisterEnabled = false
local AutoBreakDoorEnabled = false

local AutoBreakSafeConnection
local AutoBreakRegisterConnection
local AutoBreakDoorConnection

function GetSafe(Studs, IncludeBroken)
	local Closest, MinDist = nil, Studs
	for _, v in ipairs(workspace.Map.BredMakurz:GetChildren()) do
		if v:FindFirstChild("MainPart") and string.find(v.Name, "Safe") then
			local broken = v:FindFirstChild("Values") and v.Values:FindFirstChild("Broken")
			if IncludeBroken or (broken and broken.Value == false) then
				local dist = (player.Character.HumanoidRootPart.Position - v.MainPart.Position).Magnitude
				if dist < MinDist then
					MinDist = dist
					Closest = v.MainPart
				end
			end
		end
	end
	return Closest
end

function GetRegister(Studs)
	local Closest, MinDist = nil, Studs
	for _, v in ipairs(workspace.Map.BredMakurz:GetChildren()) do
		if v:FindFirstChild("MainPart") and string.find(v.Name, "Register") then
			local broken = v:FindFirstChild("Values") and v.Values:FindFirstChild("Broken")
			if broken and broken.Value == false then
				local dist = (player.Character.HumanoidRootPart.Position - v.MainPart.Position).Magnitude
				if dist < MinDist then
					MinDist = dist
					Closest = v.MainPart
				end
			end
		end
	end
	return Closest
end

function GetDoor(Studs, IncludeBroken)
	local Closest, MinDist = nil, Studs
	for _, v in ipairs(workspace.Map.BredMakurz:GetChildren()) do
		if v:FindFirstChild("MainPart") and string.find(v.Name, "Door") then
			local broken = v:FindFirstChild("Values") and v.Values:FindFirstChild("Broken")
			if IncludeBroken or (broken and broken.Value == false) then
				local dist = (player.Character.HumanoidRootPart.Position - v.MainPart.Position).Magnitude
				if dist < MinDist then
					MinDist = dist
					Closest = v.MainPart
				end
			end
		end
	end
	return Closest
end

misc1:Toggle({
	Name = "Auto BreakSafe",
	Default = false,
	Flag = "AutoBreakSafe",
	Callback = function(State)
		AutoBreakSafeEnabled = State
		if State then
			if AutoBreakSafeConnection then AutoBreakSafeConnection:Disconnect() end
			AutoBreakSafeConnection = RunService.RenderStepped:Connect(function()
				local tool = player.Character and player.Character:FindFirstChildOfClass("Tool")
				if AutoBreakSafeEnabled and tool and tool.Name == "Crowbar" then
					local Closest = GetSafe(AutoBreakSafeRangeValue, false)
					if Closest and not AutoBreakSafeCoolDown then
						AutoBreakSafeCoolDown = true
						local value = ReplicatedStorage.Events["XMHH.2"]:InvokeServer("üçû", tick(), tool, "DZDRRRKI", Closest.Parent, "Register")
						ReplicatedStorage.Events["XMHH2.2"]:FireServer("üçû", tick(), tool, "2389ZFX34", value, false, player.Character["Right Arm"], Closest, Closest.Parent, Closest.Position, Closest.Position)
						task.wait(0.5)
						AutoBreakSafeCoolDown = false
					end
				end
			end)
		else
			if AutoBreakSafeConnection then
				AutoBreakSafeConnection:Disconnect()
				AutoBreakSafeConnection = nil
			end
		end
	end
})

misc1:Toggle({
	Name = "Auto Register",
	Default = false,
	Flag = "AutoBreakRegister",
	Callback = function(State)
		AutoBreakRegisterEnabled = State
		if State then
			if AutoBreakRegisterConnection then AutoBreakRegisterConnection:Disconnect() end
			AutoBreakRegisterConnection = RunService.RenderStepped:Connect(function()
				local tool = player.Character and player.Character:FindFirstChildOfClass("Tool")
				if AutoBreakRegisterEnabled and tool and (tool.Name == "Fists" or tool.Name == "Crowbar") then
					local Closest = GetRegister(AutoBreakRegisterRangeValue)
					if Closest and not AutoBreakRegisterCoolDown then
						AutoBreakRegisterCoolDown = true
						local value = ReplicatedStorage.Events["XMHH.2"]:InvokeServer("üçû", tick(), tool, "DZDRRRKI", Closest.Parent, "Register")
						ReplicatedStorage.Events["XMHH2.2"]:FireServer("üçû", tick(), tool, "2389ZFX34", value, false, player.Character["Right Arm"], Closest, Closest.Parent, Closest.Position, Closest.Position)
						task.wait(0.5)
						AutoBreakRegisterCoolDown = false
					end
				end
			end)
		else
			if AutoBreakRegisterConnection then
				AutoBreakRegisterConnection:Disconnect()
				AutoBreakRegisterConnection = nil
			end
		end
	end
})

misc1:Toggle({
	Name = "Auto Break Doors (broken)",
	Default = false,
	Flag = "AutoBreakDoor",
	Callback = function(State)
		AutoBreakDoorEnabled = State
		if State then
			if AutoBreakDoorConnection then AutoBreakDoorConnection:Disconnect() end
			AutoBreakDoorConnection = RunService.RenderStepped:Connect(function()
				local tool = player.Character and player.Character:FindFirstChildOfClass("Tool")
				if AutoBreakDoorEnabled and tool and (tool.Name == "Crowbar" or tool.Name == "Fists") then
					local Closest = GetDoor(AutoBreakDoorRangeValue, false)
					if Closest and not AutoBreakDoorCoolDown then
						AutoBreakDoorCoolDown = true
						local value = ReplicatedStorage.Events["XMHH.2"]:InvokeServer("üçû", tick(), tool, "DZDRRRKI", Closest.Parent, "Door")
						ReplicatedStorage.Events["XMHH2.2"]:FireServer("üçû", tick(), tool, "2389ZFX34", value, false, player.Character["Right Leg"], Closest, Closest.Parent, Closest.Position, Closest.Position)
						task.wait(0.5)
						AutoBreakDoorCoolDown = false
					end
				end
			end)
		else
			if AutoBreakDoorConnection then
				AutoBreakDoorConnection:Disconnect()
				AutoBreakDoorConnection = nil
			end
		end
	end
})

local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

local farmSettings = {
	toolsFolder = Workspace:WaitForChild("Filter"):WaitForChild("SpawnedTools"),
	cashFolder = Workspace:WaitForChild("Filter"):WaitForChild("SpawnedBread"),
	pilesFolder = Workspace:WaitForChild("Filter"):WaitForChild("SpawnedPiles"),

	toolsEnabled = false,
	cashEnabled = false,
	scrapsEnabled = false,
	cratesEnabled = false,

	scrapsConnection = nil,
	toolsConnection = nil,
	cratesConnection = nil,
	moneyConnection = nil,

	canPickup = true,
	lastPickupTime = 0,
	cooldown = 0.5,

	me = Players.LocalPlayer
}

local function interactWithPrompt(v)
	if v:IsA("ProximityPrompt") and farmSettings.canPickup then
		v.HoldDuration = 0
		v:InputHoldBegin()
		v:InputHoldEnd()
		farmSettings.canPickup = false
		farmSettings.lastPickupTime = tick()
	end
end

local function pickupWithoutRemote(v)
	if farmSettings.toolsEnabled and v:IsA("Model") and farmSettings.toolsFolder:FindFirstChild(v.Name) then
		for _, p in pairs(v:GetDescendants()) do
			if p:IsA("ProximityPrompt") then interactWithPrompt(p) end
		end
	elseif farmSettings.cashEnabled and v:IsA("BasePart") and v.Name == "CashDrop1" then
		for _, p in pairs(v:GetChildren()) do
			if p:IsA("ProximityPrompt") then interactWithPrompt(p) end
		end
	elseif farmSettings.scrapsEnabled and v:IsA("Model") and (v.Name == "S1" or v.Name == "S2") then
		for _, p in pairs(v:GetDescendants()) do
			if p:IsA("ProximityPrompt") then interactWithPrompt(p) end
		end
	elseif farmSettings.cratesEnabled and v:IsA("Model") and (v.Name == "C1" or v.Name == "C2" or v.Name == "C3") then
		for _, p in pairs(v:GetDescendants()) do
			if p:IsA("ProximityPrompt") then interactWithPrompt(p) end
		end
	end
end

local scanRunning = false

local function scanItems()
	if scanRunning then return end
	scanRunning = true
	while farmSettings.toolsEnabled or farmSettings.cashEnabled or farmSettings.scrapsEnabled or farmSettings.cratesEnabled do
		if not farmSettings.canPickup and tick() - farmSettings.lastPickupTime >= farmSettings.cooldown then
			farmSettings.canPickup = true
		end
		for _, v in ipairs(farmSettings.toolsFolder:GetChildren()) do pickupWithoutRemote(v) end
		for _, v in ipairs(farmSettings.cashFolder:GetChildren()) do pickupWithoutRemote(v) end
		for _, v in ipairs(farmSettings.pilesFolder:GetChildren()) do pickupWithoutRemote(v) end
		task.wait(0.1)
	end
	scanRunning = false
end

local function pickupWithRemoteScraps()
	local remote = ReplicatedStorage:WaitForChild("Events"):WaitForChild("PIC_PU")
	if farmSettings.scrapsConnection then farmSettings.scrapsConnection:Disconnect() end
	local canPickup = true
	local lastTime = tick()
	farmSettings.scrapsConnection = RunService.RenderStepped:Connect(function()
		local closest, minDist = nil, 15
		for _, a in pairs(farmSettings.pilesFolder:GetChildren()) do
			if (a.Name == "S1" or a.Name == "S2") and farmSettings.me.Character and farmSettings.me.Character:FindFirstChild("HumanoidRootPart") then
				local mesh = a:FindFirstChild("MeshPart")
				if mesh then
					local dist = (farmSettings.me.Character.HumanoidRootPart.Position - mesh.Position).Magnitude
					if dist < minDist then
						minDist = dist
						closest = a
					end
				end
			end
		end
		if closest and canPickup then
			local attr = closest:GetAttribute("jzu")
			if attr then
				remote:FireServer(string.reverse(attr))
				canPickup = false
			end
		elseif tick() - lastTime >= 4.5 then
			canPickup = true
			lastTime = tick()
		end
	end)
end

local function pickupWithRemoteTools()
	local remote = ReplicatedStorage:WaitForChild("Events"):WaitForChild("PIC_TLO")
	if farmSettings.toolsConnection then farmSettings.toolsConnection:Disconnect() end
	local canPickup = true
	local lastTime = tick()
	farmSettings.toolsConnection = RunService.RenderStepped:Connect(function()
		local closest, minDist = nil, 15
		for _, a in pairs(farmSettings.toolsFolder:GetChildren()) do
			if farmSettings.me.Character and farmSettings.me.Character:FindFirstChild("HumanoidRootPart") then
				local handle = a:FindFirstChild("Handle") or a:FindFirstChild("WeaponHandle")
				if handle and (handle:IsA("Part") or handle:IsA("MeshPart")) then
					local dist = (farmSettings.me.Character.HumanoidRootPart.Position - handle.Position).Magnitude
					if dist < minDist then
						minDist = dist
						closest = a
					end
				end
			end
		end
		if closest and canPickup then
			local handle = closest:FindFirstChild("Handle") or closest:FindFirstChild("WeaponHandle")
			if handle then
				remote:FireServer(handle)
				canPickup = false
			end
		elseif tick() - lastTime >= 1.5 then
			canPickup = true
			lastTime = tick()
		end
	end)
end

local function pickupWithRemoteCrates()
	local remote = ReplicatedStorage:WaitForChild("Events"):WaitForChild("PIC_PU")
	if farmSettings.cratesConnection then farmSettings.cratesConnection:Disconnect() end
	local canPickup = true
	local lastTime = tick()
	farmSettings.cratesConnection = RunService.RenderStepped:Connect(function()
		local closest, minDist = nil, 15
		for _, a in pairs(farmSettings.pilesFolder:GetChildren()) do
			if (a.Name == "C1" or a.Name == "C2" or a.Name == "C3") and farmSettings.me.Character and farmSettings.me.Character:FindFirstChild("HumanoidRootPart") then
				local mesh = a:FindFirstChild("MeshPart")
				if mesh then
					local dist = (farmSettings.me.Character.HumanoidRootPart.Position - mesh.Position).Magnitude
					if dist < minDist then
						minDist = dist
						closest = a
					end
				end
			end
		end
		if closest and canPickup then
			local attr = closest:GetAttribute("jzu")
			if attr then
				remote:FireServer(string.reverse(attr))
				canPickup = false
			end
		elseif tick() - lastTime >= 7 then
			canPickup = true
			lastTime = tick()
		end
	end)
end

local function pickupWithRemoteMoney()
	local remote = ReplicatedStorage:WaitForChild("Events"):WaitForChild("CZDPZUS")
	if farmSettings.moneyConnection then farmSettings.moneyConnection:Disconnect() end
	local canPickup = true
	local lastTime = tick()
	farmSettings.moneyConnection = RunService.RenderStepped:Connect(function()
		local closest, minDist = nil, 15
		for _, a in pairs(farmSettings.cashFolder:GetChildren()) do
			if a:IsA("BasePart") and farmSettings.me.Character and farmSettings.me.Character:FindFirstChild("HumanoidRootPart") then
				local dist = (farmSettings.me.Character.HumanoidRootPart.Position - a.Position).Magnitude
				if dist < minDist then
					minDist = dist
					closest = a
				end
			end
		end
		if closest and canPickup then
			remote:FireServer(closest)
			canPickup = false
		elseif tick() - lastTime >= 0.7 then
			canPickup = true
			lastTime = tick()
		end
	end)
end

farmSettings.toolsFolder.ChildAdded:Connect(pickupWithoutRemote)
farmSettings.cashFolder.ChildAdded:Connect(pickupWithoutRemote)
farmSettings.pilesFolder.ChildAdded:Connect(pickupWithoutRemote)
Workspace.DescendantAdded:Connect(interactWithPrompt)

misc2:Toggle({
	Name = "AutoPickup Scraps",
	Default = false,
	Flag = "ToggleScraps",
	Callback = function(Value)
		farmSettings.scrapsEnabled = Value
		if farmSettings.scrapsConnection then farmSettings.scrapsConnection:Disconnect() end
		if Value then
			task.spawn(scanItems)
			task.spawn(pickupWithRemoteScraps)
		end
	end
})

misc2:Toggle({
	Name = "AutoPickup Tools",
	Default = false,
	Flag = "ToggleTools",
	Callback = function(Value)
		farmSettings.toolsEnabled = Value
		if farmSettings.toolsConnection then farmSettings.toolsConnection:Disconnect() end
		if Value then
			task.spawn(scanItems)
			task.spawn(pickupWithRemoteTools)
		end
	end
})

misc2:Toggle({
	Name = "AutoPickup Crates",
	Default = false,
	Flag = "ToggleCrates",
	Callback = function(Value)
		farmSettings.cratesEnabled = Value
		if farmSettings.cratesConnection then farmSettings.cratesConnection:Disconnect() end
		if Value then
			task.spawn(scanItems)
			task.spawn(pickupWithRemoteCrates)
		end
	end
})

misc2:Toggle({
	Name = "AutoPickup Money",
	Default = false,
	Flag = "ToggleCash",
	Callback = function(Value)
		farmSettings.cashEnabled = Value
		if farmSettings.moneyConnection then farmSettings.moneyConnection:Disconnect() end
		if Value then
			task.spawn(scanItems)
			task.spawn(pickupWithRemoteMoney)
		end
	end
})


